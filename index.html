<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAMPAGE: VOXEL FURY üß±üí•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1e 100%);
            color: #fff;
            overflow: hidden;
            margin: 0;
            width: 100vw;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #87ceeb;
            cursor: none !important;
        }

        #gameCanvas * {
            cursor: none !important;
        }

        #settings input[type="range"] {
            cursor: pointer !important;
        }

        #gameContainer {
            cursor: none !important;
        }

        #ui {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            backdrop-filter: blur(10px);
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #ui.hidden {
            opacity: 0;
            visibility: hidden;
        }

        #ui h1 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #ui .stat {
            margin: 5px 0;
            color: #ffffff;
        }

        #ui .label {
            color: #aaa;
        }

        #controls {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 90%;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 11px;
            backdrop-filter: blur(10px);
            text-align: center;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #controls.hidden {
            opacity: 0;
            visibility: hidden;
        }

        #controls .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 1px;
            color: #4ecdc4;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #4ecdc4;
        }

        #settings {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            backdrop-filter: blur(10px);
            min-width: 220px;
            max-width: 35vw;
            pointer-events: auto;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #settings.hidden {
            opacity: 0;
            visibility: hidden;
        }

        #settings h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .setting-item {
            margin: 10px 0;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 12px;
            white-space: nowrap;
            overflow: visible;
        }

        .setting-item input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .setting-value {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        .setting-note {
            color: #666;
            font-size: 10px;
            margin-top: 3px;
        }
        
        #uiToggleIndicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #4ecdc4;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            backdrop-filter: blur(10px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: none;
        }
        
        #uiToggleIndicator.visible {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <h1>üí• VOXEL FURY üß±</h1>
            <div class="stat"><span class="label">Voxels:</span> <span id="particleCount">0</span></div>
            <div class="stat"><span class="label">Destroyed:</span> <span id="destructionPercent">0</span>%</div>
            <div class="stat"><span class="label">FPS:</span> <span id="fps">60</span></div>
        </div>

        <div id="settings">
            <h3>‚öôÔ∏è Settings</h3>
            <div class="setting-item">
                <label>Voxel Size: <span class="setting-value" id="voxelSizeDisplay">3mm</span></label>
                <input type="range" id="voxelSizeSlider" min="2" max="8" value="3" step="1">
                <div class="setting-note">2‚Äì8mm. Smaller = more detail but slower</div>
            </div>
            <div class="setting-item">
                <label>Place Amount: <span class="setting-value" id="placeAmountDisplay">20</span></label>
                <input type="range" id="placeAmountSlider" min="1" max="50" value="20" step="1">
                <div class="setting-note">Radius when placing (1 = single voxel | 50 = large blob)</div>
            </div>
        </div>

        <div id="controls">
            <div><span class="key">CLICK+DRAG</span> Destroy | <span class="key">R</span> Rebuild | <span class="key">H</span> Hide UI</div>
            <div style="margin-top: 6px; color: #4ecdc4; font-weight: bold;">Liquid</div>
            <div style="margin-top: 2px;"><span class="key">3</span> Water <span class="key">5</span> Lava <span class="key">6</span> Acid <span class="key">9</span> Oil <span class="key">0</span> Steam <span class="key">Q</span> Blood <span class="key">W</span> Slime <span class="key">I</span> Honey <span class="key">D</span> Mercury</div>
            <div style="margin-top: 6px; color: #4ecdc4; font-weight: bold;">Solid</div>
            <div style="margin-top: 2px;"><span class="key">1</span> Concrete <span class="key">2</span> Dust <span class="key">4</span> Metal <span class="key">8</span> Snow <span class="key">E</span> Fire <span class="key">Y</span> Ice <span class="key">U</span> Sand <span class="key">O</span> Gravel</div>
            <div style="margin-top: 2px;"><span class="key">P</span> Wood <span class="key">G</span> Gunpowder <span class="key">J</span> Stone <span class="key">K</span> Ember <span class="key">F</span> Feces</div>
            <div style="margin-top: 2px;"><span class="key">V</span> Lead Brick <span class="key">M</span> Lead Ball <span class="key">N</span> Glue Metal <span class="key">A</span> Pellets <span class="key">S</span> Fuse <span class="key">.</span> Rubber <span class="key">Z</span> Milk <span class="key">`</span> Antimatter (ignite w/ fire)</div>
            <div style="margin-top: 6px; color: #4ecdc4; font-weight: bold;">Life</div>
            <div style="margin-top: 2px;"><span class="key">7</span> Human <span class="key">B</span> Builder <span class="key">T</span> Plant <span class="key">L</span> Flies <span class="key">X</span> Worm <span class="key">C</span> Bacteria</div>
        </div>
        
        <div id="uiToggleIndicator">Press H to show UI</div>
    </div>

    <script>
        // ============================================
        // RAMPAGE: VOXEL FURY
        // Pixel-Perfect Destruction Physics Sandbox
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // Game Configuration
        let CONFIG = {
            width: 1280,
            height: 720,
            pixelSize: 3, // Size of each voxel particle in mm (1-8mm)
            gravity: 0.5,
            destroyRadius: 25,
            spawnRadius: 20 // How many voxels placed when spawning (radius of placement circle)
        };

        // Set canvas size
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;

        // Calculate grid dimensions (will be recalculated when voxel size changes)
        let GRID_WIDTH = Math.floor(CONFIG.width / CONFIG.pixelSize);
        let GRID_HEIGHT = Math.floor(CONFIG.height / CONFIG.pixelSize);

        // Material Types
        const MATERIAL = {
            EMPTY: 0,
            CONCRETE: 1,
            METAL: 2,
            GLASS: 3,
            DUST: 4,
            LIQUID: 5,
            LAVA: 6,
            ACID: 7,
            HUMAN_HEAD: 8,
            HUMAN_BODY: 9,           // Normal human - blue shirt, does not build
            HUMAN_BODY_BUILDER: 26,  // Builder human - yellow shirt, builds at edges
            DEAD_HUMAN: 10,  // Red unmoving voxels (acid victims)
            SNOW: 11,        // White particles, accumulate, cold
            OIL: 12,         // Dark liquid, flammable
            STEAM: 13,       // Gas that rises instead of falls
            BLOOD: 14,       // Red liquid
            SLIME: 15,       // Slow viscous liquid
            FIRE: 16,        // Spreads and burns, rises
            PLANT: 17,       // Living material that grows
            ICE: 18,         // Solid that melts into water
            SAND: 19,        // Fast-falling particles
            HONEY: 20,       // Very viscous golden liquid
            GRAVEL: 21,      // Heavy fast-falling particles
            WOOD: 22,        // Burnable solid
            GUNPOWDER: 23,   // Explosive particles
            STONE: 24,       // Heavy solid, rugged
            EMBER: 25,       // Hot glowing particles that rise
            FEECES: 27,      // Brown solid, attracts flies
            FLY: 28,         // Life form - buzzes toward feces
            LEAD: 29,        // Heavy ball - sticks together, launched by gunpowder, kills humans on impact
            GLUE_METAL: 30,  // Sticky metal - adjacent blocks won't fall (like slime/honey)
            MILK: 31,        // White liquid - flows like water
            WORM: 32,        // Life form - 1 pink moving particle
            LEAD_BRICK: 33,  // Like concrete but immune to lead ball destruction
            BACTERIA: 34,    // Life form - reproduces near nutrients, dies from heat/acid
            MERCURY: 35,     // Dense liquid metal - sinks through other liquids, toxic
            PELLET: 36,      // Light shot - small, launched in spread for shotgun contraptions
            FUSE: 37,        // Burnable solid - carries fire along its length for chain ignition
            RUBBER: 38,      // Bouncy block - deflects lead and pellets
            ANTIMATTER: 39,  // Purple powder - ignite with fire for purple/blue blast!
            ANTIMATTER_BLAST: 40  // Purple-blue blast from antimatter explosion (rises, destroys)
        };

        // Material Properties
        const MATERIAL_PROPS = {
            [MATERIAL.EMPTY]: { color: null, density: 0, strength: 0 },
            [MATERIAL.CONCRETE]: { color: '#5a6268', density: 8, strength: 5, flow: false, shadeBase: [90, 98, 104] },
            [MATERIAL.METAL]: { color: '#8899aa', density: 10, strength: 8, flow: false, shadeBase: [136, 153, 170] },
            [MATERIAL.GLASS]: { color: '#4a9eff', density: 4, strength: 2, flow: false, shadeBase: [74, 158, 255] },
            [MATERIAL.DUST]: { color: '#c4a574', density: 2, strength: 0, flow: true, shadeBase: [196, 165, 116] },
            [MATERIAL.LIQUID]: { color: '#2563eb', density: 3, strength: 0, flow: true, shadeBase: [37, 99, 235] },
            [MATERIAL.LAVA]: { color: '#ff4500', density: 6, strength: 0, flow: true, shadeBase: [255, 69, 0], glows: true },
            [MATERIAL.ACID]: { color: '#00ff41', density: 2, strength: 0, flow: true, shadeBase: [0, 255, 65], corrosive: true },
            [MATERIAL.HUMAN_HEAD]: { color: '#ff69b4', density: 5, strength: 3, flow: false, shadeBase: [255, 105, 180], isHuman: true },
            [MATERIAL.HUMAN_BODY]: { color: '#4169e1', density: 5, strength: 3, flow: false, shadeBase: [65, 105, 225], isHuman: true },
            [MATERIAL.HUMAN_BODY_BUILDER]: { color: '#ffd700', density: 5, strength: 3, flow: false, shadeBase: [255, 215, 0], isHuman: true },
            [MATERIAL.DEAD_HUMAN]: { color: '#ff0000', density: 100, strength: 0, flow: false, shadeBase: [255, 0, 0], static: true },
            [MATERIAL.SNOW]: { color: '#ffffff', density: 1, strength: 0, flow: true, shadeBase: [255, 255, 255], cold: true },
            [MATERIAL.OIL]: { color: '#2d2d2d', density: 2, strength: 0, flow: true, shadeBase: [45, 45, 45], flammable: true },
            [MATERIAL.STEAM]: { color: '#e8e8e8', density: 0.5, strength: 0, flow: true, shadeBase: [232, 232, 232], rises: true },
            [MATERIAL.BLOOD]: { color: '#8b0000', density: 3, strength: 0, flow: true, shadeBase: [139, 0, 0] },
            [MATERIAL.SLIME]: { color: '#32cd32', density: 4, strength: 0, flow: true, shadeBase: [50, 205, 50], viscous: true },
            [MATERIAL.FIRE]: { color: '#ff8c00', density: 0.3, strength: 0, flow: true, shadeBase: [255, 140, 0], burns: true, rises: true },
            [MATERIAL.PLANT]: { color: '#228b22', density: 3, strength: 2, flow: false, shadeBase: [34, 139, 34], grows: true },
            [MATERIAL.ICE]: { color: '#add8e6', density: 5, strength: 3, flow: false, shadeBase: [173, 216, 230], melts: true },
            [MATERIAL.SAND]: { color: '#f4a460', density: 4, strength: 0, flow: true, shadeBase: [244, 164, 96] },
            [MATERIAL.HONEY]: { color: '#daa520', density: 5, strength: 0, flow: true, shadeBase: [218, 165, 32], viscous: true },
            [MATERIAL.GRAVEL]: { color: '#6b6b6b', density: 6, strength: 0, flow: true, shadeBase: [107, 107, 107] },
            [MATERIAL.WOOD]: { color: '#8b4513', density: 5, strength: 4, flow: false, shadeBase: [139, 69, 19], flammable: true },
            [MATERIAL.GUNPOWDER]: { color: '#3d3d3d', density: 3, strength: 0, flow: true, shadeBase: [61, 61, 61], explosive: true },
            [MATERIAL.STONE]: { color: '#696969', density: 9, strength: 6, flow: false, shadeBase: [105, 105, 105] },
            [MATERIAL.EMBER]: { color: '#ff6b35', density: 0.4, strength: 0, flow: true, shadeBase: [255, 107, 53], rises: true },
            [MATERIAL.FEECES]: { color: '#5d4037', density: 4, strength: 1, flow: false, shadeBase: [93, 64, 55], attractsFlies: true },
            [MATERIAL.FLY]: { color: '#1a1a1a', density: 0.2, strength: 0, flow: false, shadeBase: [26, 26, 26], isFly: true },
            [MATERIAL.LEAD]: { color: '#36454f', density: 12, strength: 6, flow: false, shadeBase: [54, 69, 79], isLead: true },
            [MATERIAL.GLUE_METAL]: { color: '#708090', density: 7, strength: 4, flow: false, shadeBase: [112, 128, 144], sticky: true },
            [MATERIAL.MILK]: { color: '#f5f5dc', density: 3, strength: 0, flow: true, shadeBase: [245, 245, 220] },
            [MATERIAL.WORM]: { color: '#ff69b4', density: 0.3, strength: 0, flow: false, shadeBase: [255, 105, 180], isWorm: true },
            [MATERIAL.LEAD_BRICK]: { color: '#3d4f5c', density: 9, strength: 6, flow: false, shadeBase: [61, 79, 92] },
            [MATERIAL.BACTERIA]: { color: '#7cfc00', density: 1, strength: 0, flow: false, shadeBase: [124, 252, 0], grows: true },
            [MATERIAL.MERCURY]: { color: '#b8b8b8', density: 14, strength: 0, flow: true, shadeBase: [184, 184, 184], toxic: true },
            [MATERIAL.PELLET]: { color: '#8b7355', density: 4, strength: 2, flow: false, shadeBase: [139, 115, 85], isPellet: true },
            [MATERIAL.FUSE]: { color: '#4a3728', density: 2, strength: 1, flow: false, shadeBase: [74, 55, 40], flammable: true, isFuse: true },
            [MATERIAL.RUBBER]: { color: '#2d2d2d', density: 3, strength: 3, flow: false, shadeBase: [45, 45, 50], bouncy: true },
            [MATERIAL.ANTIMATTER]: { color: '#8b008b', density: 3, strength: 0, flow: true, shadeBase: [139, 0, 139], explosive: true },
            [MATERIAL.ANTIMATTER_BLAST]: { color: '#8a2be2', density: 0.3, strength: 0, flow: true, shadeBase: [120, 80, 255], burns: true, rises: true }
        };

        // Game State
        class Game {
            constructor() {
                this.grid = new Array(GRID_WIDTH * GRID_HEIGHT).fill(MATERIAL.EMPTY);
                this.velocityX = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
                this.velocityY = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
                this.particleAge = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0); // Track when debris was created
                this.humanBuiltBlocks = new Array(GRID_WIDTH * GRID_HEIGHT).fill(false); // Track blocks placed by humans (sticky)
                this.plantType = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0); // 0=green leaf, 1=brown stem, 2+=flower colors
                this.mouse = { x: -1000, y: -1000, down: false, isInCanvas: false }; // Start off-screen to prevent initial cursor
                this.particleCount = 0;
                this.initialParticles = 0;
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.humans = []; // Track human entities (each human is 2 voxels)
                this.nextHumanId = 0;
                this.flies = [];  // Track fly entities (1 voxel each)
                this.nextFlyId = 0;
                this.leadBalls = []; // Track lead balls (connected voxel clusters)
                this.nextLeadBallId = 0;
                this.pelletBalls = []; // Track pellet shots (small projectiles, spread launch)
                this.nextPelletId = 0;
                this.worms = []; // Track worm entities (1 pink particle each)
                this.nextWormId = 0;
            }

            // Reinitialize grid when voxel size changes
            reinitializeGrid() {
                const newSize = GRID_WIDTH * GRID_HEIGHT;
                this.grid = new Array(newSize).fill(MATERIAL.EMPTY);
                this.velocityX = new Array(newSize).fill(0);
                this.velocityY = new Array(newSize).fill(0);
                this.particleAge = new Array(newSize).fill(0);
                this.humanBuiltBlocks = new Array(newSize).fill(false);
                this.plantType = new Array(newSize).fill(0);
                this.humans = []; // Clear all humans
                this.nextHumanId = 0;
                this.flies = [];
                this.nextFlyId = 0;
                this.leadBalls = [];
                this.nextLeadBallId = 0;
                this.pelletBalls = [];
                this.nextPelletId = 0;
                this.worms = [];
                this.nextWormId = 0;
                this.generateBuildings();
            }

            getIndex(x, y) {
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return -1;
                return Math.floor(y) * GRID_WIDTH + Math.floor(x);
            }

            get(x, y) {
                const idx = this.getIndex(x, y);
                return idx === -1 ? MATERIAL.EMPTY : this.grid[idx];
            }

            set(x, y, material) {
                const idx = this.getIndex(x, y);
                if (idx !== -1) this.grid[idx] = material;
            }

            isEmpty(x, y) {
                return this.get(x, y) === MATERIAL.EMPTY;
            }

            // Check empty in a specific grid (for sim - target cells use newGrid)
            isEmptyIn(grid, x, y) {
                const idx = this.getIndex(x, y);
                return idx === -1 ? true : grid[idx] === MATERIAL.EMPTY;
            }

            // Generate procedural buildings
            generateBuildings() {
                const groundLevel = GRID_HEIGHT - 15;
                
                // Ground
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = groundLevel; y < GRID_HEIGHT; y++) {
                        this.set(x, y, MATERIAL.CONCRETE);
                    }
                }

                // Generate 6-8 buildings
                const numBuildings = 6 + Math.floor(Math.random() * 3);
                const spacing = GRID_WIDTH / numBuildings;

                for (let i = 0; i < numBuildings; i++) {
                    const x = Math.floor(i * spacing + spacing * 0.25);
                    const width = Math.floor(spacing * 0.45 + Math.random() * spacing * 0.25);
                    const height = Math.floor(60 + Math.random() * 120);
                    const floors = Math.floor(height / 20);

                    // Building structure with varied materials
                    for (let bx = x; bx < x + width; bx++) {
                        for (let by = groundLevel - height; by < groundLevel; by++) {
                            // Edge columns are stronger (concrete/metal)
                            if (bx === x || bx === x + width - 1) {
                                this.set(bx, by, MATERIAL.CONCRETE);
                            } else {
                                const material = Math.random() < 0.75 ? MATERIAL.CONCRETE : 
                                               Math.random() < 0.6 ? MATERIAL.METAL : MATERIAL.GLASS;
                                this.set(bx, by, material);
                            }
                        }
                    }

                    // Windows (glass sections)
                    for (let floor = 0; floor < floors; floor++) {
                        const floorY = groundLevel - height + floor * 20 + 4;
                        for (let wx = x + 3; wx < x + width - 3; wx += 6) {
                            for (let wy = floorY; wy < floorY + 10; wy += 1) {
                                if (wx + 2 < x + width - 3 && Math.random() < 0.8) {
                                    this.set(wx, wy, MATERIAL.GLASS);
                                    this.set(wx + 1, wy, MATERIAL.GLASS);
                                }
                            }
                        }
                    }
                }

                this.countParticles();
                this.initialParticles = this.particleCount;
            }

            // Update humans - they move as connected entities
            updateHumans() {
                for (let i = this.humans.length - 1; i >= 0; i--) {
                    const human = this.humans[i];
                    
                    if (!human.alive) continue;
                    
                    // Check if acid is touching the human
                    const neighbors = [
                        [human.headX, human.headY + 1],
                        [human.headX, human.headY - 1],
                        [human.headX - 1, human.headY],
                        [human.headX + 1, human.headY],
                        [human.bodyX, human.bodyY + 1],
                        [human.bodyX, human.bodyY - 1],
                        [human.bodyX - 1, human.bodyY],
                        [human.bodyX + 1, human.bodyY]
                    ];
                    
                    let touchingAcid = false;
                    let touchingMercury = false;
                    for (const [nx, ny] of neighbors) {
                        const n = this.get(nx, ny);
                        if (n === MATERIAL.ACID) touchingAcid = true;
                        if (n === MATERIAL.MERCURY) touchingMercury = true;
                        if (touchingAcid || touchingMercury) break;
                    }
                    
                    // If acid or mercury (toxic) touches human, convert to static red voxels
                    if (touchingAcid || touchingMercury) {
                        this.set(human.headX, human.headY, MATERIAL.DEAD_HUMAN);
                        this.set(human.bodyX, human.bodyY, MATERIAL.DEAD_HUMAN);
                        human.alive = false;
                        continue;
                    }
                    
                    // Check if human parts still exist
                    const headExists = this.get(human.headX, human.headY) === MATERIAL.HUMAN_HEAD;
                    const bodyExists = this.get(human.bodyX, human.bodyY) === MATERIAL.HUMAN_BODY || 
                                       this.get(human.bodyX, human.bodyY) === MATERIAL.HUMAN_BODY_BUILDER;
                    
                    if (!headExists && !bodyExists) {
                        // Both parts destroyed, remove human
                        this.humans.splice(i, 1);
                        continue;
                    }
                    
                    if (!headExists || !bodyExists) {
                        // One part destroyed, human falls apart
                        human.alive = false;
                        continue;
                    }
                    
                    // Apply gravity
                    human.vy += CONFIG.gravity;
                    
                    // Check if can fall (sink in water and acid too)
                    const below = this.get(human.bodyX, human.bodyY + 1);
                    const canFall = below === MATERIAL.EMPTY || below === MATERIAL.LIQUID || below === MATERIAL.ACID;
                    
                    if (canFall && human.vy > 0) {
                        // Move both voxels down together (falling/sinking)
                        const bodyMat = human.isBuilder ? MATERIAL.HUMAN_BODY_BUILDER : MATERIAL.HUMAN_BODY;
                        // When sinking into liquid/acid, displace it upward to where head was
                        if (below === MATERIAL.LIQUID || below === MATERIAL.ACID) {
                            this.set(human.headX, human.headY, below); // Liquid rises to fill head space
                        } else {
                            this.set(human.headX, human.headY, MATERIAL.EMPTY);
                        }
                        this.set(human.bodyX, human.bodyY, MATERIAL.EMPTY);
                        
                        human.headY += 1;
                        human.bodyY += 1;
                        
                        this.set(human.headX, human.headY, MATERIAL.HUMAN_HEAD);
                        this.set(human.bodyX, human.bodyY, bodyMat);
                    } else {
                        // On ground - Builder AI behavior
                        human.vy = 0;
                        
                        // Try to walk in current direction
                        const nextX = human.bodyX + human.direction;
                        const nextHeadX = human.headX + human.direction;
                        
                        // Check what's ahead
                        const canMoveBody = this.isEmpty(nextX, human.bodyY);
                        const canMoveHead = this.isEmpty(nextHeadX, human.headY);
                        const groundAhead = this.get(nextX, human.bodyY + 1);
                        const hasGround = groundAhead !== MATERIAL.EMPTY;
                        
                        // Check if there's a climbable block (1 level up)
                        // Climbing conditions:
                        // 1. Block at body level ahead (the stair/ledge)
                        // 2. Empty space above that block (where body will go)
                        // 3. Empty space for head above that
                        const hasBlockAtBodyLevel = !this.isEmpty(nextX, human.bodyY);
                        const hasSpaceAbove = this.isEmpty(nextX, human.bodyY - 1);
                        const hasSpaceForHead = this.isEmpty(nextX, human.bodyY - 2);
                        const canClimb = hasBlockAtBodyLevel && hasSpaceAbove && hasSpaceForHead;
                        
                        if (canClimb) {
                            // CLIMB UP one level
                            const bodyMat = human.isBuilder ? MATERIAL.HUMAN_BODY_BUILDER : MATERIAL.HUMAN_BODY;
                            this.set(human.headX, human.headY, MATERIAL.EMPTY);
                            this.set(human.bodyX, human.bodyY, MATERIAL.EMPTY);
                            
                            human.bodyX = nextX;
                            human.bodyY = human.bodyY - 1;
                            human.headX = nextX;
                            human.headY = human.headY - 1;
                            
                            this.set(human.headX, human.headY, MATERIAL.HUMAN_HEAD);
                            this.set(human.bodyX, human.bodyY, bodyMat);
                            
                            human.justBuilt = false;
                        } else if ((!canMoveBody || !canMoveHead) && !canClimb) {
                            // Hit a wall - turn around
                            human.direction *= -1;
                            human.justBuilt = false;
                        } else if (!hasGround && human.isBuilder) {
                            // At an edge - Builder humans BUILD OUTWARD to extend the platform with RANDOMNESS
                            const buildX = nextX;
                            const normalBuildY = human.bodyY + 1; // Ground level
                            
                            // RANDOM BUILDING DECISIONS for organic structures:
                            // 25% chance to build upward (stairs)
                            const buildUpward = Math.random() < 0.25;
                            // 10% chance to build a tower (2-4 blocks high)
                            const buildTower = Math.random() < 0.10;
                            // 5% chance to skip this block entirely (creates gaps)
                            const skipBlock = Math.random() < 0.05;
                            
                            if (skipBlock) {
                                // Occasionally don't build, turn around
                                human.direction *= -1;
                                human.justBuilt = false;
                            } else {
                                // Check if we can build at ground level
                                const materialAtGroundPos = this.get(buildX, normalBuildY);
                                const canBuildGround = materialAtGroundPos === MATERIAL.EMPTY || 
                                    materialAtGroundPos === MATERIAL.ACID || materialAtGroundPos === MATERIAL.MERCURY ||
                                    materialAtGroundPos === MATERIAL.LIQUID ||
                                    materialAtGroundPos === MATERIAL.LAVA ||
                                    materialAtGroundPos === MATERIAL.OIL ||
                                    materialAtGroundPos === MATERIAL.BLOOD ||
                                    materialAtGroundPos === MATERIAL.SLIME ||
                                    materialAtGroundPos === MATERIAL.HONEY;
                                
                                if (canBuildGround) {
                                    // Always build ground block first
                                    this.set(buildX, normalBuildY, MATERIAL.CONCRETE);
                                    const groundIdx = this.getIndex(buildX, normalBuildY);
                                    if (groundIdx !== -1) {
                                        this.humanBuiltBlocks[groundIdx] = true;
                                    }
                                    
                                    // RANDOM UPWARD BUILDING for variety
                                    if (buildTower) {
                                        // Build a small tower (2-4 blocks high)
                                        const towerHeight = Math.floor(Math.random() * 3) + 2; // 2 to 4 blocks
                                        for (let h = 0; h < towerHeight; h++) {
                                            const towerY = normalBuildY - h - 1;
                                            const materialAtTowerPos = this.get(buildX, towerY);
                                            if (materialAtTowerPos === MATERIAL.EMPTY || 
                                                materialAtTowerPos === MATERIAL.ACID || materialAtTowerPos === MATERIAL.MERCURY ||
                                                materialAtTowerPos === MATERIAL.LIQUID ||
                                                materialAtTowerPos === MATERIAL.LAVA ||
                                                materialAtTowerPos === MATERIAL.OIL ||
                                                materialAtTowerPos === MATERIAL.BLOOD ||
                                                materialAtTowerPos === MATERIAL.SLIME ||
                                                materialAtTowerPos === MATERIAL.HONEY) {
                                                
                                                this.set(buildX, towerY, MATERIAL.CONCRETE);
                                                const towerIdx = this.getIndex(buildX, towerY);
                                                if (towerIdx !== -1) {
                                                    this.humanBuiltBlocks[towerIdx] = true;
                                                }
                                            }
                                        }
                                    } else if (buildUpward) {
                                        // Build single stair step (one level up)
                                        const upperBuildY = human.bodyY; // One level up
                                        const materialAtUpperPos = this.get(buildX, upperBuildY);
                                        if (materialAtUpperPos === MATERIAL.EMPTY || 
                                            materialAtUpperPos === MATERIAL.ACID || materialAtUpperPos === MATERIAL.MERCURY ||
                                            materialAtUpperPos === MATERIAL.LIQUID ||
                                            materialAtUpperPos === MATERIAL.LAVA ||
                                            materialAtUpperPos === MATERIAL.OIL ||
                                            materialAtUpperPos === MATERIAL.BLOOD ||
                                            materialAtUpperPos === MATERIAL.SLIME ||
                                            materialAtUpperPos === MATERIAL.HONEY) {
                                            
                                            this.set(buildX, upperBuildY, MATERIAL.CONCRETE);
                                            const upperIdx = this.getIndex(buildX, upperBuildY);
                                            if (upperIdx !== -1) {
                                                this.humanBuiltBlocks[upperIdx] = true;
                                            }
                                        }
                                    }
                                    
                                    human.justBuilt = true;
                                    
                                    // Turn around after building
                                    human.direction *= -1;
                                } else {
                                    // Can't build here, turn around
                                    human.direction *= -1;
                                    human.justBuilt = false;
                                }
                            }
                        } else if (!hasGround && !human.isBuilder) {
                            // Normal human at edge - turn around (no building)
                            human.direction *= -1;
                            human.justBuilt = false;
                        } else {
                            // Normal walking - path is clear
                            human.justBuilt = false;
                            
                            // 3% chance to randomly change direction while walking (adds unpredictability)
                            if (Math.random() < 0.03) {
                                human.direction *= -1;
                            } else {
                                // Move horizontally
                                const bodyMat = human.isBuilder ? MATERIAL.HUMAN_BODY_BUILDER : MATERIAL.HUMAN_BODY;
                                this.set(human.headX, human.headY, MATERIAL.EMPTY);
                                this.set(human.bodyX, human.bodyY, MATERIAL.EMPTY);
                                
                                human.headX = nextHeadX;
                                human.bodyX = nextX;
                                
                                this.set(human.headX, human.headY, MATERIAL.HUMAN_HEAD);
                                this.set(human.bodyX, human.bodyY, bodyMat);
                            }
                        }
                    }
                }
            }

            // Find nearest feces within range (returns [x,y] or null)
            findNearestFeces(flyX, flyY, range) {
                let nearest = null;
                let nearestDist = range + 1;
                for (let gy = Math.max(0, flyY - range); gy <= Math.min(GRID_HEIGHT - 1, flyY + range); gy++) {
                    for (let gx = Math.max(0, flyX - range); gx <= Math.min(GRID_WIDTH - 1, flyX + range); gx++) {
                        if (this.get(gx, gy) === MATERIAL.FEECES) {
                            const dist = Math.sqrt((gx - flyX) ** 2 + (gy - flyY) ** 2);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = [gx, gy];
                            }
                        }
                    }
                }
                return nearest;
            }

            // Update flies - they buzz toward feces when nearby
            updateFlies() {
                const FEECES_ATTRACT_RANGE = 18;
                for (let i = this.flies.length - 1; i >= 0; i--) {
                    const fly = this.flies[i];
                    if (!fly.alive) continue;

                    // Check if acid or fire touching fly - dies
                    const neighbors = [
                        [fly.x, fly.y + 1], [fly.x, fly.y - 1], [fly.x - 1, fly.y], [fly.x + 1, fly.y]
                    ];
                    for (const [nx, ny] of neighbors) {
                        const m = this.get(nx, ny);
                        if (m === MATERIAL.ACID || m === MATERIAL.FIRE || m === MATERIAL.LAVA || m === MATERIAL.MERCURY) {
                            this.set(fly.x, fly.y, MATERIAL.EMPTY);
                            fly.alive = false;
                            this.flies.splice(i, 1);
                            break;
                        }
                    }
                    if (!fly.alive) continue;

                    if (this.get(fly.x, fly.y) !== MATERIAL.FLY) {
                        this.flies.splice(i, 1);
                        continue;
                    }

                    const feces = this.findNearestFeces(fly.x, fly.y, FEECES_ATTRACT_RANGE);
                    let moveX = 0, moveY = 0;

                    if (feces) {
                        // Move toward feces (flies buzz downward toward it)
                        const dx = feces[0] - fly.x;
                        const dy = feces[1] - fly.y;
                        if (Math.abs(dx) > Math.abs(dy)) {
                            moveX = dx > 0 ? 1 : -1;
                        } else {
                            moveY = dy > 0 ? 1 : -1;
                        }
                    } else {
                        // Random buzz: prefer up, occasionally horizontal
                        if (Math.random() < 0.4) moveY = -1;
                        else if (Math.random() < 0.2) moveY = 1;
                        if (Math.random() < 0.5) moveX = Math.random() < 0.5 ? -1 : 1;
                    }

                    const newX = fly.x + moveX;
                    const newY = fly.y + moveY;
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && this.isEmpty(newX, newY)) {
                        this.set(fly.x, fly.y, MATERIAL.EMPTY);
                        fly.x = newX;
                        fly.y = newY;
                        this.set(fly.x, fly.y, MATERIAL.FLY);
                    }
                }
            }

            // Update worms - 1 pink particle that wiggles around
            updateWorms() {
                for (let i = this.worms.length - 1; i >= 0; i--) {
                    const worm = this.worms[i];

                    if (this.get(worm.x, worm.y) !== MATERIAL.WORM) {
                        this.worms.splice(i, 1);
                        continue;
                    }

                    // Die if touching acid, fire, or lava
                    const neighbors = [[worm.x, worm.y + 1], [worm.x, worm.y - 1], [worm.x - 1, worm.y], [worm.x + 1, worm.y]];
                    for (const [nx, ny] of neighbors) {
                        const m = this.get(nx, ny);
                        if (m === MATERIAL.ACID || m === MATERIAL.FIRE || m === MATERIAL.LAVA || m === MATERIAL.MERCURY) {
                            this.set(worm.x, worm.y, MATERIAL.EMPTY);
                            this.worms.splice(i, 1);
                            break;
                        }
                    }
                    if (this.worms[i] !== worm) continue;

                    // Wiggle movement: prefer horizontal, sometimes up/down
                    let moveX = 0, moveY = 0;
                    if (Math.random() < 0.6) moveX = Math.random() < 0.5 ? -1 : 1;
                    else if (Math.random() < 0.5) moveY = -1;
                    else moveY = 1;

                    const newX = worm.x + moveX;
                    const newY = worm.y + moveY;
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && this.isEmpty(newX, newY)) {
                        this.set(worm.x, worm.y, MATERIAL.EMPTY);
                        worm.x = newX;
                        worm.y = newY;
                        this.set(worm.x, worm.y, MATERIAL.WORM);
                    }
                }
            }

            // Lead ball shape: rough sphere pattern (big ball, ~13 voxels)
            getLeadBallShape() {
                const voxels = [];
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d <= 2.2) voxels.push({ x: dx, y: dy });
                    }
                }
                return voxels;
            }

            // Launch pellets within explosion radius - SPREAD pattern (shotgun style)
            launchPelletsNear(ex, ey, radius) {
                for (const ball of this.pelletBalls) {
                    const dist = Math.sqrt((ball.cx - ex) ** 2 + (ball.cy - ey) ** 2);
                    if (dist <= radius) {
                        const dx = ball.cx - ex, dy = ball.cy - ey;
                        const mag = Math.sqrt(dx * dx + dy * dy) || 1;
                        const baseForce = 5 + (radius - dist) * 0.6;
                        const spread = (Math.random() - 0.5) * 0.8;
                        const angle = Math.atan2(dy, dx) + spread;
                        const force = baseForce * (0.8 + Math.random() * 0.4);
                        ball.vx += Math.cos(angle) * force;
                        ball.vy += Math.sin(angle) * force;
                    }
                }
            }

            // Launch lead balls within explosion radius (gunpowder explosion)
            launchLeadBallsNear(ex, ey, radius) {
                for (const ball of this.leadBalls) {
                    let minDist = radius + 1;
                    for (const v of ball.voxels) {
                        const dist = Math.sqrt((ball.cx + v.x - ex) ** 2 + (ball.cy + v.y - ey) ** 2);
                        if (dist < minDist) minDist = dist;
                    }
                    if (minDist <= radius) {
                        const dx = ball.cx - ex, dy = ball.cy - ey;
                        const mag = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = 6 + (radius - minDist) * 0.8;
                        ball.vx += (dx / mag) * force;
                        ball.vy += (dy / mag) * force;
                    }
                }
            }

            // Update lead balls - move as connected unit, gravity, kill humans on impact
            updateLeadBalls() {
                const shape = this._leadShape || (this._leadShape = this.getLeadBallShape());
                for (let i = this.leadBalls.length - 1; i >= 0; i--) {
                    const ball = this.leadBalls[i];
                    const voxels = ball.voxels.map(v => ({ x: ball.cx + v.x, y: ball.cy + v.y }));

                    let exists = voxels.every(({ x, y }) => this.get(x, y) === MATERIAL.LEAD);
                    if (!exists) {
                        for (const { x, y } of voxels) {
                            if (this.get(x, y) === MATERIAL.LEAD) this.set(x, y, MATERIAL.GRAVEL);
                        }
                        this.leadBalls.splice(i, 1);
                        continue;
                    }

                    ball.vy += CONFIG.gravity;
                    ball.vx *= 0.98;
                    ball.vy *= 0.98;

                    const moveX = Math.round(ball.vx);
                    const moveY = Math.round(ball.vy);
                    if (moveX === 0 && moveY === 0) continue;

                    const newVoxels = voxels.map(({ x, y }) => ({ x: x + moveX, y: y + moveY }));
                    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const hitsGunpowder = speed > 2 && newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.GUNPOWDER);
                    if (hitsGunpowder) {
                        for (const { x, y } of newVoxels) {
                            if (this.get(x, y) === MATERIAL.GUNPOWDER) this.set(x, y, MATERIAL.FIRE);
                        }
                        ball.vx *= -0.3;
                        ball.vy *= -0.3;
                        continue;
                    }
                    const hitsSlimeOrHoney = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        return m === MATERIAL.SLIME || m === MATERIAL.HONEY;
                    });
                    if (hitsSlimeOrHoney) {
                        ball.vx *= -1.35;
                        ball.vy *= -1.35;
                        continue;
                    }
                    const hitsGlueMetal = newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.GLUE_METAL);
                    if (hitsGlueMetal) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsLeadBrick = newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.LEAD_BRICK);
                    if (hitsLeadBrick) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsRubber = newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.RUBBER);
                    if (hitsRubber) {
                        if (speed > 2) this.screenShake = Math.min(12, this.screenShake + speed * 0.8);
                        ball.vx *= -1.5;
                        ball.vy *= -1.5;
                        continue;
                    }
                    const hitsHuman = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        return m === MATERIAL.HUMAN_HEAD || m === MATERIAL.HUMAN_BODY || m === MATERIAL.HUMAN_BODY_BUILDER;
                    });

                    if (hitsHuman && speed > 2) {
                        for (const h of this.humans) {
                            if (!h.alive) continue;
                            const touched = newVoxels.some(({ x, y }) =>
                                (x === h.headX && y === h.headY) || (x === h.bodyX && y === h.bodyY));
                            if (touched) {
                                this.set(h.headX, h.headY, MATERIAL.DEAD_HUMAN);
                                this.set(h.bodyX, h.bodyY, MATERIAL.DEAD_HUMAN);
                                h.alive = false;
                            }
                        }
                        ball.vx *= 0.5;
                        ball.vy *= 0.5;
                    }

                    for (const { x, y } of voxels) this.set(x, y, MATERIAL.EMPTY);
                    for (const { x, y } of newVoxels) {
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT)
                            this.set(x, y, MATERIAL.LEAD);
                    }
                    ball.cx += moveX;
                    ball.cy += moveY;
                }
            }

            // Update pellets - single-voxel projectiles, lighter than lead, bounce off rubber
            updatePellets() {
                for (let i = this.pelletBalls.length - 1; i >= 0; i--) {
                    const ball = this.pelletBalls[i];
                    const px = ball.cx, py = ball.cy;
                    if (this.get(px, py) !== MATERIAL.PELLET) {
                        this.pelletBalls.splice(i, 1);
                        continue;
                    }
                    ball.vy += CONFIG.gravity * 1.2;
                    ball.vx *= 0.98;
                    ball.vy *= 0.98;
                    const moveX = Math.round(ball.vx);
                    const moveY = Math.round(ball.vy);
                    if (moveX === 0 && moveY === 0) continue;
                    const newX = px + moveX, newY = py + moveY;
                    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const targetMat = this.get(newX, newY);
                    const hitsGunpowder = speed > 2 && targetMat === MATERIAL.GUNPOWDER;
                    if (hitsGunpowder) {
                        this.set(newX, newY, MATERIAL.FIRE);
                        ball.vx *= -0.3;
                        ball.vy *= -0.3;
                        continue;
                    }
                    const hitsSlimeOrHoney = targetMat === MATERIAL.SLIME || targetMat === MATERIAL.HONEY;
                    if (hitsSlimeOrHoney) {
                        if (speed > 3) this.screenShake = Math.min(12, this.screenShake + speed * 0.8);
                        ball.vx *= -1.2;
                        ball.vy *= -1.2;
                        continue;
                    }
                    const hitsGlueMetal = targetMat === MATERIAL.GLUE_METAL;
                    if (hitsGlueMetal) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsLeadBrick = targetMat === MATERIAL.LEAD_BRICK;
                    if (hitsLeadBrick) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsRubber = targetMat === MATERIAL.RUBBER;
                    if (hitsRubber) {
                        if (speed > 2) this.screenShake = Math.min(10, this.screenShake + speed * 0.6);
                        ball.vx *= -1.6;
                        ball.vy *= -1.6;
                        continue;
                    }
                    const hitsHuman = targetMat === MATERIAL.HUMAN_HEAD || targetMat === MATERIAL.HUMAN_BODY || targetMat === MATERIAL.HUMAN_BODY_BUILDER;
                    if (hitsHuman && speed > 2) {
                        for (const h of this.humans) {
                            if (!h.alive) continue;
                            if ((newX === h.headX && newY === h.headY) || (newX === h.bodyX && newY === h.bodyY)) {
                                this.set(h.headX, h.headY, MATERIAL.DEAD_HUMAN);
                                this.set(h.bodyX, h.bodyY, MATERIAL.DEAD_HUMAN);
                                h.alive = false;
                            }
                        }
                        ball.vx *= 0.5;
                        ball.vy *= 0.5;
                    }
                    if (targetMat !== MATERIAL.EMPTY && !hitsHuman) {
                        this.set(px, py, MATERIAL.DUST);
                        this.pelletBalls.splice(i, 1);
                        continue;
                    }
                    this.set(px, py, MATERIAL.EMPTY);
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT)
                        this.set(newX, newY, MATERIAL.PELLET);
                    ball.cx = newX;
                    ball.cy = newY;
                }
            }

            // Physics simulation (cellular automata)
            simulate() {
                // Update humans first (they move as units)
                this.updateHumans();
                this.updateFlies();
                this.updateWorms();
                this.updateLeadBalls();
                this.updatePellets();
                
                const newGrid = [...this.grid];
                const newVelX = [...this.velocityX];
                const newVelY = [...this.velocityY];
                const now = Date.now();

                // Clean up old debris particles (disappear after 2 seconds)
                for (let i = 0; i < this.grid.length; i++) {
                    if (this.grid[i] === MATERIAL.DUST && this.particleAge[i] > 0) {
                        if (now - this.particleAge[i] > 2000) {
                            newGrid[i] = MATERIAL.EMPTY;
                            this.particleAge[i] = 0;
                        }
                    }
                }

                // Process all cells in random order so voxels fall together (not by row)
                const totalCells = GRID_WIDTH * GRID_HEIGHT;
                if (!this._simOrder || this._simOrder.length !== totalCells) {
                    this._simOrder = new Int32Array(totalCells);
                    for (let i = 0; i < totalCells; i++) this._simOrder[i] = i;
                }
                for (let i = totalCells - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    const t = this._simOrder[i];
                    this._simOrder[i] = this._simOrder[j];
                    this._simOrder[j] = t;
                }
                const emptyIn = (g, ax, ay) => this.isEmptyIn(g, ax, ay);
                for (let si = 0; si < totalCells; si++) {
                    const idx = this._simOrder[si];
                    const y = Math.floor(idx / GRID_WIDTH);
                    const x = idx % GRID_WIDTH;
                    if (y >= GRID_HEIGHT - 1) continue;
                        const material = this.grid[idx];

                        if (material === MATERIAL.EMPTY) continue;
                        
                        // Skip human materials - they're handled separately as connected entities
                        if (material === MATERIAL.HUMAN_HEAD || material === MATERIAL.HUMAN_BODY || material === MATERIAL.HUMAN_BODY_BUILDER) continue;
                        
                        // Skip flies - they're handled separately as life-form entities
                        if (material === MATERIAL.FLY) continue;
                        
                        // Skip lead - handled as connected ball entities
                        if (material === MATERIAL.LEAD) continue;
                        
                        // Skip pellets - handled as projectile entities
                        if (material === MATERIAL.PELLET) continue;
                        
                        // Skip worms - handled as life-form entities
                        if (material === MATERIAL.WORM) continue;
                        
                        // Skip dead humans - they don't move (static red voxels)
                        if (material === MATERIAL.DEAD_HUMAN) continue;

                        const props = MATERIAL_PROPS[material];
                        const vx = this.velocityX[idx];
                        const vy = this.velocityY[idx];

                        // Apply gravity
                        let newVY = vy + CONFIG.gravity;
                        let newVX = vx * 0.95; // Friction

                        let moved = false;

                        // LAVA: Burns and melts weaker materials
                        if (material === MATERIAL.LAVA) {
                            // Lava destroys weaker materials (not metal or concrete)
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            // WATER + LAVA = Stone (molten rock cools when quenched)
                            let lavaQuenched = false;
                            for (const [nx, ny] of neighbors) {
                                if (this.get(nx, ny) === MATERIAL.LIQUID) {
                                    newGrid[idx] = MATERIAL.STONE;
                                    newGrid[this.getIndex(nx, ny)] = MATERIAL.STEAM;
                                    lavaQuenched = true;
                                    break;
                                }
                            }
                            if (!lavaQuenched) {
                                for (const [nx, ny] of neighbors) {
                                    const neighborMat = this.get(nx, ny);
                                    // SAND + LAVA = Glass (silica melts and forms glass)
                                    if (neighborMat === MATERIAL.SAND && Math.random() < 0.25) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.GLASS;
                                    }
                                    // METAL + LAVA: Metal melts (high heat melts metals)
                                    else if (neighborMat === MATERIAL.METAL && Math.random() < 0.08) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LAVA;
                                    }
                                    // Burns dust, glass, humans and converts them to lava or dust
                                    else if ((neighborMat === MATERIAL.DUST || neighborMat === MATERIAL.GLASS || neighborMat === MATERIAL.WOOD) && Math.random() < 0.2) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LAVA;
                                    } else if (neighborMat === MATERIAL.FUSE && Math.random() < 0.95) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.GUNPOWDER) {
                                        // LAVA + GUNPOWDER = GIANT EXPLOSION
                                        const explosionRadius = 8;
                                        for (let ex = nx - explosionRadius; ex <= nx + explosionRadius; ex++) {
                                            for (let ey = ny - explosionRadius; ey <= ny + explosionRadius; ey++) {
                                                const dist = Math.sqrt((ex - nx) ** 2 + (ey - ny) ** 2);
                                                if (dist <= explosionRadius && this.get(ex, ey) === MATERIAL.GUNPOWDER) {
                                                    newGrid[this.getIndex(ex, ey)] = MATERIAL.FIRE;
                                                }
                                                if (dist <= explosionRadius * 0.6 && (this.get(ex, ey) === MATERIAL.DUST || this.get(ex, ey) === MATERIAL.WOOD || this.get(ex, ey) === MATERIAL.PLANT)) {
                                                    if (Math.random() < 0.7) newGrid[this.getIndex(ex, ey)] = MATERIAL.FIRE;
                                                }
                                            }
                                        }
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.FIRE;
                                        this.launchLeadBallsNear(nx, ny, explosionRadius);
                                        this.launchPelletsNear(nx, ny, explosionRadius);
                                        break; // One explosion per lava voxel
                                    } else if (neighborMat === MATERIAL.ANTIMATTER) {
                                        // LAVA + ANTIMATTER = Purple/blue blast (4 voxel core destroys everything)
                                        const blastEx = nx, blastEy = ny;
                                        for (let bx = blastEx - 12; bx <= blastEx + 12; bx++) {
                                            for (let by = blastEy - 12; by <= blastEy + 12; by++) {
                                                const dist = Math.sqrt((bx - blastEx) ** 2 + (by - blastEy) ** 2);
                                                const bIdx = this.getIndex(bx, by);
                                                if (bIdx === -1) continue;
                                                if (dist <= 4) newGrid[bIdx] = MATERIAL.EMPTY;
                                                else if (dist <= 12 && this.get(bx, by) !== MATERIAL.EMPTY) newGrid[bIdx] = MATERIAL.ANTIMATTER_BLAST;
                                            }
                                        }
                                        this.launchLeadBallsNear(blastEx, blastEy, 12);
                                        this.launchPelletsNear(blastEx, blastEy, 12);
                                        for (const h of this.humans) {
                                            const hDist = Math.sqrt((h.headX - blastEx) ** 2 + (h.headY - blastEy) ** 2);
                                            if (hDist <= 12) {
                                                newGrid[this.getIndex(h.headX, h.headY)] = MATERIAL.DEAD_HUMAN;
                                                newGrid[this.getIndex(h.bodyX, h.bodyY)] = MATERIAL.DEAD_HUMAN;
                                                h.alive = false;
                                            }
                                        }
                                        break;
                                    } else if ((neighborMat === MATERIAL.HUMAN_HEAD || neighborMat === MATERIAL.HUMAN_BODY || neighborMat === MATERIAL.HUMAN_BODY_BUILDER) && Math.random() < 0.15) {
                                        // Humans burn to dust
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.DUST;
                                    }
                                }
                            }
                        }

                        // ACID: Destroys everything it touches - EXTREMELY satisfying!
                        if (material === MATERIAL.ACID) {
                            // Check all 8 neighbors and destroy them aggressively
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y],
                                [x - 1, y + 1], [x + 1, y + 1], [x - 1, y - 1], [x + 1, y - 1]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if (neighborMat !== MATERIAL.EMPTY && neighborMat !== MATERIAL.ACID && neighborMat !== MATERIAL.DEAD_HUMAN && neighborMat !== MATERIAL.SLIME && neighborMat !== MATERIAL.HONEY && neighborMat !== MATERIAL.MERCURY) {
                                    let corrodeChance = 0.7;
                                    if (neighborMat === MATERIAL.STONE) corrodeChance = 0.06;
                                    else if (neighborMat === MATERIAL.METAL) corrodeChance = 0.12;
                                    else if (neighborMat === MATERIAL.CONCRETE || neighborMat === MATERIAL.LEAD_BRICK) corrodeChance = 0.45;
                                    if ((neighborMat === MATERIAL.HUMAN_HEAD || neighborMat === MATERIAL.HUMAN_BODY || neighborMat === MATERIAL.HUMAN_BODY_BUILDER) && Math.random() < 0.7) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.DEAD_HUMAN;
                                    }
                                    else if (Math.random() < corrodeChance) {
                                        newGrid[this.getIndex(nx, ny)] = neighborMat === MATERIAL.METAL ? MATERIAL.DUST : MATERIAL.EMPTY;
                                    }
                                }
                            }
                            
                            // Sometimes acid also spreads aggressively to dissolve more
                            if (Math.random() < 0.2) {
                                const spreadDir = Math.random() < 0.5 ? -1 : 1;
                                const spreadX = x + spreadDir;
                                const spreadY = y;
                                const spreadMat = this.get(spreadX, spreadY);
                                if (spreadMat !== MATERIAL.EMPTY && spreadMat !== MATERIAL.ACID && spreadMat !== MATERIAL.SLIME && spreadMat !== MATERIAL.HONEY) {
                                    newGrid[this.getIndex(spreadX, spreadY)] = MATERIAL.ACID;
                                }
                            }
                        }

                        // FIRE: Burns materials and rises like smoke
                        if (material === MATERIAL.FIRE) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            // WATER extinguishes FIRE - produces steam
                            let fireExtinguished = false;
                            for (const [nx, ny] of neighbors) {
                                if (this.get(nx, ny) === MATERIAL.LIQUID) {
                                    newGrid[idx] = MATERIAL.STEAM;
                                    fireExtinguished = true;
                                    break;
                                }
                            }
                            if (!fireExtinguished) {
                                for (const [nx, ny] of neighbors) {
                                    const neighborMat = this.get(nx, ny);
                                    const nIdx = this.getIndex(nx, ny);
                                    
                                    // GUNPOWDER + FIRE = GIANT EXPLOSION
                                    if (neighborMat === MATERIAL.GUNPOWDER) {
                                        const explosionRadius = 8;
                                        for (let ex = nx - explosionRadius; ex <= nx + explosionRadius; ex++) {
                                            for (let ey = ny - explosionRadius; ey <= ny + explosionRadius; ey++) {
                                                const dist = Math.sqrt((ex - nx) ** 2 + (ey - ny) ** 2);
                                                if (dist <= explosionRadius && this.get(ex, ey) === MATERIAL.GUNPOWDER) {
                                                    newGrid[this.getIndex(ex, ey)] = MATERIAL.FIRE;
                                                }
                                                if (dist <= explosionRadius * 0.6 && (this.get(ex, ey) === MATERIAL.DUST || this.get(ex, ey) === MATERIAL.WOOD || this.get(ex, ey) === MATERIAL.PLANT)) {
                                                    if (Math.random() < 0.7) newGrid[this.getIndex(ex, ey)] = MATERIAL.FIRE;
                                                }
                                            }
                                        }
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                        this.launchLeadBallsNear(nx, ny, explosionRadius);
                                        this.launchPelletsNear(nx, ny, explosionRadius);
                                        break; // One explosion per fire voxel
                                    } else if (neighborMat === MATERIAL.ANTIMATTER) {
                                        // FIRE + ANTIMATTER = Purple/blue blast (4 voxel core destroys everything)
                                        const blastEx = nx, blastEy = ny;
                                        for (let bx = blastEx - 12; bx <= blastEx + 12; bx++) {
                                            for (let by = blastEy - 12; by <= blastEy + 12; by++) {
                                                const dist = Math.sqrt((bx - blastEx) ** 2 + (by - blastEy) ** 2);
                                                const bIdx = this.getIndex(bx, by);
                                                if (bIdx === -1) continue;
                                                if (dist <= 4) newGrid[bIdx] = MATERIAL.EMPTY;
                                                else if (dist <= 12 && this.get(bx, by) !== MATERIAL.EMPTY) newGrid[bIdx] = MATERIAL.ANTIMATTER_BLAST;
                                            }
                                        }
                                        this.launchLeadBallsNear(blastEx, blastEy, 12);
                                        this.launchPelletsNear(blastEx, blastEy, 12);
                                        for (const h of this.humans) {
                                            const hDist = Math.sqrt((h.headX - blastEx) ** 2 + (h.headY - blastEy) ** 2);
                                            if (hDist <= 12) {
                                                newGrid[this.getIndex(h.headX, h.headY)] = MATERIAL.DEAD_HUMAN;
                                                newGrid[this.getIndex(h.bodyX, h.bodyY)] = MATERIAL.DEAD_HUMAN;
                                                h.alive = false;
                                            }
                                        }
                                        break;
                                    } else if (neighborMat === MATERIAL.FUSE) {
                                        if (Math.random() < 0.92) newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.OIL && Math.random() < 0.3) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.BLOOD && Math.random() < 0.2) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.FEECES && Math.random() < 0.08) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.PLANT && Math.random() < 0.2) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.WOOD) {
                                        const woodWet = this.get(nx, ny - 1) === MATERIAL.LIQUID || this.get(nx, ny + 1) === MATERIAL.LIQUID ||
                                            this.get(nx - 1, ny) === MATERIAL.LIQUID || this.get(nx + 1, ny) === MATERIAL.LIQUID;
                                        if (Math.random() < (woodWet ? 0.06 : 0.25)) newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.ICE && Math.random() < 0.1) {
                                        newGrid[nIdx] = MATERIAL.LIQUID;
                                    }
                                }
                                
                                if (Math.random() < 0.008) {
                                    const emberDirs = [[x, y - 1], [x - 1, y - 1], [x + 1, y - 1], [x - 1, y], [x + 1, y]];
                                    for (const [ex, ey] of emberDirs) {
                                        if (emptyIn(newGrid, ex, ey) && Math.random() < 0.5) {
                                            newGrid[this.getIndex(ex, ey)] = MATERIAL.EMBER;
                                            break;
                                        }
                                    }
                                }
                                
                                // Fire dies out randomly
                                if (Math.random() < 0.05) {
                                    newGrid[idx] = MATERIAL.STEAM;
                                }
                            }
                        }

                        // ANTIMATTER_BLAST: Purple/blue blast - ignites antimatter (chain reaction), burns things
                        if (material === MATERIAL.ANTIMATTER_BLAST) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                const nIdx = this.getIndex(nx, ny);
                                if (neighborMat === MATERIAL.ANTIMATTER) {
                                    // Chain reaction: antimatter ignites!
                                    const blastEx = nx, blastEy = ny;
                                    for (let bx = blastEx - 12; bx <= blastEx + 12; bx++) {
                                        for (let by = blastEy - 12; by <= blastEy + 12; by++) {
                                            const dist = Math.sqrt((bx - blastEx) ** 2 + (by - blastEy) ** 2);
                                            const bIdx = this.getIndex(bx, by);
                                            if (bIdx === -1) continue;
                                            if (dist <= 4) newGrid[bIdx] = MATERIAL.EMPTY;
                                            else if (dist <= 12 && this.get(bx, by) !== MATERIAL.EMPTY) newGrid[bIdx] = MATERIAL.ANTIMATTER_BLAST;
                                        }
                                    }
                                    this.launchLeadBallsNear(blastEx, blastEy, 12);
                                    this.launchPelletsNear(blastEx, blastEy, 12);
                                    for (const h of this.humans) {
                                        const hDist = Math.sqrt((h.headX - blastEx) ** 2 + (h.headY - blastEy) ** 2);
                                        if (hDist <= 12) {
                                            newGrid[this.getIndex(h.headX, h.headY)] = MATERIAL.DEAD_HUMAN;
                                            newGrid[this.getIndex(h.bodyX, h.bodyY)] = MATERIAL.DEAD_HUMAN;
                                            h.alive = false;
                                        }
                                    }
                                    break;
                                } else if (neighborMat === MATERIAL.WOOD || neighborMat === MATERIAL.PLANT || neighborMat === MATERIAL.OIL) {
                                    if (Math.random() < 0.15) newGrid[nIdx] = MATERIAL.ANTIMATTER_BLAST;
                                }
                            }
                            if (Math.random() < 0.03) newGrid[idx] = MATERIAL.EMPTY; // Blast fades
                        }

                        if (material === MATERIAL.PLANT) {
                            const hasWater = this.get(x, y - 1) === MATERIAL.LIQUID || this.get(x, y + 1) === MATERIAL.LIQUID ||
                                this.get(x - 1, y) === MATERIAL.LIQUID || this.get(x + 1, y) === MATERIAL.LIQUID;
                            const growthChance = hasWater ? 0.014 : 0.008;
                            if (Math.random() < growthChance) {
                                const hasGroundBelow = !emptyIn(newGrid, x, y + 1);
                                const growthChoices = [];
                                
                                if (Math.random() < 0.5 && emptyIn(newGrid, x, y - 1)) {
                                    growthChoices.push([x, y - 1]);
                                }
                                if (Math.random() < 0.25) {
                                    if (emptyIn(newGrid, x - 1, y)) growthChoices.push([x - 1, y]);
                                    if (emptyIn(newGrid, x + 1, y)) growthChoices.push([x + 1, y]);
                                }
                                if (Math.random() < 0.15) {
                                    if (emptyIn(newGrid, x - 1, y - 1)) growthChoices.push([x - 1, y - 1]);
                                    if (emptyIn(newGrid, x + 1, y - 1)) growthChoices.push([x + 1, y - 1]);
                                }
                                if (Math.random() < 0.10 && emptyIn(newGrid, x, y + 1)) {
                                    growthChoices.push([x, y + 1]);
                                }
                                
                                // Grow in a random chosen direction
                                if (growthChoices.length > 0) {
                                    const [gx, gy] = growthChoices[Math.floor(Math.random() * growthChoices.length)];
                                    const growIdx = this.getIndex(gx, gy);
                                    
                                    // Check for nearby plants to create dense clusters
                                    const nearbyPlants = [
                                        [gx, gy - 1], [gx, gy + 1], [gx - 1, gy], [gx + 1, gy]
                                    ].filter(([nx, ny]) => this.get(nx, ny) === MATERIAL.PLANT).length;
                                    
                                    // More likely to grow if near other plants (clustering effect)
                                    if (nearbyPlants > 0 || Math.random() < 0.6) {
                                        newGrid[growIdx] = MATERIAL.PLANT;
                                        
                                        // Assign plant type: 55% green, 35% brown stem, 10% flower
                                        const r = Math.random();
                                        if (r < 0.10) {
                                            // Flower - bright colors: yellow, red, pink, orange, magenta
                                            this.plantType[growIdx] = 2 + Math.floor(Math.random() * 5);
                                        } else if (r < 0.45) {
                                            this.plantType[growIdx] = 1; // Brown stem
                                        } else {
                                            this.plantType[growIdx] = 0; // Green leaf
                                        }
                                    }
                                }
                                
                                // Small chance to stop growing (die back) if too isolated
                                if (Math.random() < 0.001) {
                                    const nearbyPlants = [
                                        [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]
                                    ].filter(([nx, ny]) => this.get(nx, ny) === MATERIAL.PLANT).length;
                                    
                                    if (nearbyPlants === 0) {
                                        newGrid[idx] = MATERIAL.EMPTY; // Isolated plants die
                                        this.plantType[idx] = 0; // Clear plant type
                                    }
                                }
                            }
                        }

                        // ICE: Melts near hot materials
                        if (material === MATERIAL.ICE) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.LAVA || neighborMat === MATERIAL.FIRE) && Math.random() < 0.3) {
                                    newGrid[idx] = MATERIAL.LIQUID; // Melts to water
                                    break;
                                }
                            }
                        }

                        // SNOW: Melts near hot materials, accumulates
                        if (material === MATERIAL.SNOW) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.LAVA || neighborMat === MATERIAL.FIRE) && Math.random() < 0.4) {
                                    newGrid[idx] = MATERIAL.LIQUID; // Melts to water
                                    break;
                                }
                            }
                        }

                        // GUNPOWDER + WATER: Becomes inert (wet gunpowder doesn't explode)
                        if (material === MATERIAL.GUNPOWDER) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            for (const [nx, ny] of neighbors) {
                                if (this.get(nx, ny) === MATERIAL.LIQUID) {
                                    newGrid[idx] = MATERIAL.DUST;
                                    break;
                                }
                            }
                        }

                        // WATER: Freezes when surrounded by ice/snow (cold transfers)
                        if (material === MATERIAL.LIQUID) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            let coldCount = 0;
                            for (const [nx, ny] of neighbors) {
                                const n = this.get(nx, ny);
                                if (n === MATERIAL.ICE || n === MATERIAL.SNOW) coldCount++;
                            }
                            if (coldCount >= 2 && Math.random() < 0.08) {
                                newGrid[idx] = MATERIAL.ICE;
                            }
                        }

                        // OIL: Ignites near fire
                        if (material === MATERIAL.OIL) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.FIRE || neighborMat === MATERIAL.LAVA) && Math.random() < 0.5) {
                                    newGrid[idx] = MATERIAL.FIRE; // Oil catches fire!
                                    break;
                                }
                            }
                        }

                        // STEAM: Condenses to water when near cold (ice, snow) or at top of screen
                        if (material === MATERIAL.STEAM) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            const atTop = y < GRID_HEIGHT * 0.1;
                            let nearCold = false;
                            for (const [nx, ny] of neighbors) {
                                const n = this.get(nx, ny);
                                if (n === MATERIAL.ICE || n === MATERIAL.SNOW) {
                                    nearCold = true;
                                    break;
                                }
                            }
                            if ((nearCold || atTop) && Math.random() < 0.15) {
                                newGrid[idx] = MATERIAL.LIQUID;
                            }
                        }

                        // STEAM: Rises (handled in flow section with special logic)
                        // BLOOD: Acts like water but thicker
                        // SLIME: Very slow viscous liquid (handled in flow)
                        // SAND: Fast-falling particles (handled in flow)

                        // BACTERIA: Reproduces near nutrients (water, blood, milk, feces), dies from heat/acid/mercury
                        if (material === MATERIAL.BACTERIA) {
                            // Die from acid, fire, lava, mercury (toxic)
                            const deadlyNeighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y],
                                [x - 1, y + 1], [x + 1, y + 1], [x - 1, y - 1], [x + 1, y - 1]
                            ];
                            let willDie = false;
                            for (const [nx, ny] of deadlyNeighbors) {
                                const n = this.get(nx, ny);
                                if (n === MATERIAL.ACID || n === MATERIAL.FIRE || n === MATERIAL.LAVA || n === MATERIAL.MERCURY) {
                                    willDie = true;
                                    break;
                                }
                            }
                            if (willDie) {
                                newGrid[idx] = MATERIAL.EMPTY;
                            } else {
                                // Reproduce when near nutrients (water, blood, milk, feces)
                                const nutrientMats = [MATERIAL.LIQUID, MATERIAL.BLOOD, MATERIAL.MILK, MATERIAL.FEECES];
                                let hasNutrient = false;
                                for (const [nx, ny] of [[x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]]) {
                                    if (nutrientMats.includes(this.get(nx, ny))) {
                                        hasNutrient = true;
                                        break;
                                    }
                                }
                                if (hasNutrient && Math.random() < 0.02) {
                                    const growChoices = [
                                        [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y],
                                        [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1], [x + 1, y + 1]
                                    ].filter(([gx, gy]) => emptyIn(newGrid, gx, gy));
                                    if (growChoices.length > 0) {
                                        const [gx, gy] = growChoices[Math.floor(Math.random() * growChoices.length)];
                                        newGrid[this.getIndex(gx, gy)] = MATERIAL.BACTERIA;
                                    }
                                }
                            }
                        }

                        // Flow behavior for dust and liquids (skip if particle was transformed, e.g. bacteria killed)
                        if (newGrid[idx] !== material) { moved = true; } // Already transformed, skip flow
                        else if (props.flow) {
                            // STEAM, FIRE, EMBER, and ANTIMATTER_BLAST rise instead of fall
                            if (material === MATERIAL.STEAM || material === MATERIAL.FIRE || material === MATERIAL.EMBER || material === MATERIAL.ANTIMATTER_BLAST) {
                                if (emptyIn(newGrid, x, y - 1)) {
                                    const targetIdx = this.getIndex(x, y - 1);
                                    newGrid[targetIdx] = material;
                                    newGrid[idx] = MATERIAL.EMPTY;
                                    moved = true;
                                }
                                else if (emptyIn(newGrid, x - 1, y - 1) || emptyIn(newGrid, x + 1, y - 1)) {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    const nx = x + (emptyIn(newGrid, x + dir, y - 1) ? dir : -dir);
                                    if (emptyIn(newGrid, nx, y - 1)) {
                                        const targetIdx = this.getIndex(nx, y - 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    }
                                }
                                else {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    if (emptyIn(newGrid, x + dir, y)) {
                                        const targetIdx = this.getIndex(x + dir, y);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    }
                                }
                            }
                            // SLIME is viscous - moves slowly
                            else if (material === MATERIAL.SLIME) {
                                if (Math.random() < 0.3) {
                                    if (emptyIn(newGrid, x, y + 1)) {
                                        const targetIdx = this.getIndex(x, y + 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    } else if (emptyIn(newGrid, x - 1, y + 1) || emptyIn(newGrid, x + 1, y + 1)) {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        const nx = x + (emptyIn(newGrid, x + dir, y + 1) ? dir : -dir);
                                        if (emptyIn(newGrid, nx, y + 1)) {
                                            const targetIdx = this.getIndex(nx, y + 1);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    } else {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        if (emptyIn(newGrid, x + dir, y)) {
                                            const targetIdx = this.getIndex(x + dir, y);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    }
                                }
                            }
                            // HONEY is very viscous - even slower than slime
                            else if (material === MATERIAL.HONEY) {
                                if (Math.random() < 0.15) {
                                    if (emptyIn(newGrid, x, y + 1)) {
                                        const targetIdx = this.getIndex(x, y + 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    } else if (emptyIn(newGrid, x - 1, y + 1) || emptyIn(newGrid, x + 1, y + 1)) {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        const nx = x + (emptyIn(newGrid, x + dir, y + 1) ? dir : -dir);
                                        if (emptyIn(newGrid, nx, y + 1)) {
                                            const targetIdx = this.getIndex(nx, y + 1);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    } else {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        if (emptyIn(newGrid, x + dir, y)) {
                                            const targetIdx = this.getIndex(x + dir, y);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    }
                                }
                            }
                            else {
                                if (emptyIn(newGrid, x, y + 1)) {
                                    const targetIdx = this.getIndex(x, y + 1);
                                    newGrid[targetIdx] = material;
                                    newGrid[idx] = MATERIAL.EMPTY;
                                    newVelY[targetIdx] = newVY;
                                    newVelX[targetIdx] = newVX;
                                    if (material === MATERIAL.DUST && this.particleAge[idx] > 0) {
                                        this.particleAge[targetIdx] = this.particleAge[idx];
                                        this.particleAge[idx] = 0;
                                    }
                                    moved = true;
                                }
                                else if (emptyIn(newGrid, x - 1, y + 1) || emptyIn(newGrid, x + 1, y + 1)) {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    const nx = x + (emptyIn(newGrid, x + dir, y + 1) ? dir : -dir);
                                    if (emptyIn(newGrid, nx, y + 1)) {
                                        const targetIdx = this.getIndex(nx, y + 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelY[targetIdx] = newVY;
                                        newVelX[targetIdx] = newVX;
                                        if (material === MATERIAL.DUST && this.particleAge[idx] > 0) {
                                            this.particleAge[targetIdx] = this.particleAge[idx];
                                            this.particleAge[idx] = 0;
                                        }
                                        moved = true;
                                    }
                                }
                                else if (material === MATERIAL.LIQUID || material === MATERIAL.LAVA || 
                                         material === MATERIAL.ACID || material === MATERIAL.OIL || 
                                         material === MATERIAL.BLOOD || material === MATERIAL.MILK || material === MATERIAL.MERCURY) {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    if (emptyIn(newGrid, x + dir, y)) {
                                        const targetIdx = this.getIndex(x + dir, y);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelX[targetIdx] = dir * (material === MATERIAL.LAVA ? 1 : material === MATERIAL.MERCURY ? 1 : 2);
                                        moved = true;
                                    }
                                }
                            }
                        }
                        // Solid materials check for support
                        else {
                            // SLIME/HONEY GLUE: Any block touching slime or honey is stuck - won't fall (floating metal!)
                            const touchingSticky = this.get(x, y - 1) === MATERIAL.SLIME || this.get(x, y - 1) === MATERIAL.HONEY || this.get(x, y - 1) === MATERIAL.GLUE_METAL ||
                                                  this.get(x, y + 1) === MATERIAL.SLIME || this.get(x, y + 1) === MATERIAL.HONEY || this.get(x, y + 1) === MATERIAL.GLUE_METAL ||
                                                  this.get(x - 1, y) === MATERIAL.SLIME || this.get(x - 1, y) === MATERIAL.HONEY || this.get(x - 1, y) === MATERIAL.GLUE_METAL ||
                                                  this.get(x + 1, y) === MATERIAL.SLIME || this.get(x + 1, y) === MATERIAL.HONEY || this.get(x + 1, y) === MATERIAL.GLUE_METAL;
                            
                            // STICKY BLOCKS: Human-built blocks are sticky; PLANTS need ground support
                            const isHumanBuilt = this.humanBuiltBlocks[idx];
                            
                            const hasDirectSupport = !emptyIn(newGrid, x, y + 1);
                            
                            if (!hasDirectSupport && !touchingSticky) {
                                if (material === MATERIAL.PLANT) {
                                    if (emptyIn(newGrid, x, y + 1)) {
                                        const ti = this.getIndex(x, y + 1);
                                        newGrid[ti] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelY[ti] = newVY;
                                        this.plantType[ti] = this.plantType[idx];
                                        this.plantType[idx] = 0;
                                        moved = true;
                                    }
                                }
                                else if (isHumanBuilt) {
                                    const hasLeftNeighbor = !emptyIn(newGrid, x - 1, y);
                                    const hasRightNeighbor = !emptyIn(newGrid, x + 1, y);
                                    const hasTopNeighbor = !emptyIn(newGrid, x, y - 1);
                                    const hasAnyConnection = hasLeftNeighbor || hasRightNeighbor || hasTopNeighbor;
                                    
                                    if (!hasAnyConnection && emptyIn(newGrid, x, y + 1)) {
                                        const ti = this.getIndex(x, y + 1);
                                        newGrid[ti] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelY[ti] = newVY;
                                        this.humanBuiltBlocks[ti] = true;
                                        this.humanBuiltBlocks[idx] = false;
                                        moved = true;
                                    }
                                } else {
                                    const leftSupport = !emptyIn(newGrid, x - 1, y) && !emptyIn(newGrid, x - 1, y + 1);
                                    const rightSupport = !emptyIn(newGrid, x + 1, y) && !emptyIn(newGrid, x + 1, y + 1);
                                    
                                    if ((!leftSupport && !rightSupport) || Math.random() < 0.02) {
                                        if (emptyIn(newGrid, x, y + 1)) {
                                            const ti = this.getIndex(x, y + 1);
                                            newGrid[ti] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            newVelY[ti] = newVY;
                                            moved = true;
                                        }
                                    }
                                }
                            }
                        }

                        if (!moved) {
                            newVelY[idx] = 0;
                            newVelX[idx] = 0;
                    }
                }
                // Density-based liquid layering: swap vertical pairs where heavier is above lighter
                for (let py = 0; py < GRID_HEIGHT - 1; py++) {
                    for (let px = 0; px < GRID_WIDTH; px++) {
                        const uIdx = this.getIndex(px, py);
                        const dIdx = this.getIndex(px, py + 1);
                        if (uIdx === -1 || dIdx === -1) continue;
                        const upper = newGrid[uIdx];
                        const lower = newGrid[dIdx];
                        const upProps = MATERIAL_PROPS[upper];
                        const loProps = MATERIAL_PROPS[lower];
                        if (upper !== MATERIAL.EMPTY && lower !== MATERIAL.EMPTY &&
                            upProps && upProps.flow && loProps && loProps.flow &&
                            !upProps.rises && !loProps.rises &&
                            (upProps.density || 0) > (loProps.density || 0) && Math.random() < 0.4) {
                            newGrid[uIdx] = lower;
                            newGrid[dIdx] = upper;
                            const vx = newVelX[uIdx], vy = newVelY[uIdx];
                            newVelX[uIdx] = newVelX[dIdx]; newVelY[uIdx] = newVelY[dIdx];
                            newVelX[dIdx] = vx; newVelY[dIdx] = vy;
                        }
                    }
                }
                this.grid = newGrid;
                this.velocityX = newVelX;
                this.velocityY = newVelY;
            }



            // Mouse destruction
            destroyAtMouse() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const radius = CONFIG.destroyRadius / CONFIG.pixelSize;
                const now = Date.now();

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const x = mx + dx;
                            const y = my + dy;
                            const material = this.get(x, y);
                            
                            if (material !== MATERIAL.EMPTY) {
                                const destroyChance = 1.0 - (dist / radius) * 0.6;
                                if (Math.random() < destroyChance) {
                                    const idx = this.getIndex(x, y);
                                    if (Math.random() < 0.5) {
                                        this.set(x, y, MATERIAL.DUST);
                                        const angle = Math.atan2(dy, dx);
                                        this.velocityX[idx] = Math.cos(angle) * (4 + Math.random() * 2);
                                        this.velocityY[idx] = Math.sin(angle) * (4 + Math.random() * 2);
                                        // Set timestamp for debris to disappear after 2 seconds
                                        this.particleAge[idx] = now;
                                    } else {
                                        this.set(x, y, MATERIAL.EMPTY);
                                    }
                                    // Clear flags when destroyed
                                    if (idx !== -1) {
                                        this.humanBuiltBlocks[idx] = false;
                                        this.plantType[idx] = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Spawn material at mouse
            spawnMaterial(material) {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const radius = CONFIG.spawnRadius;

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius && Math.random() < 0.7) {
                            this.set(mx + dx, my + dy, material);
                        }
                    }
                }
            }

            // Spawn small plant seeds (1-3 voxels)
            spawnPlant() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                
                // Spawn 1-3 small seed voxels instead of a large circle
                const seedCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < seedCount; i++) {
                    const offsetX = Math.floor(Math.random() * 5) - 2;
                    const offsetY = Math.floor(Math.random() * 5) - 2;
                    const seedX = mx + offsetX;
                    const seedY = my + offsetY;
                    
                    if (this.isEmpty(seedX, seedY)) {
                        this.set(seedX, seedY, MATERIAL.PLANT);
                        const seedIdx = this.getIndex(seedX, seedY);
                        if (seedIdx !== -1) {
                            // Seeds start as green (0), occasionally brown (1)
                            this.plantType[seedIdx] = Math.random() < 0.2 ? 1 : 0;
                        }
                    }
                }
            }

            // Spawn a normal human (2 voxels: pink head, blue shirt) - does NOT build
            spawnHuman() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                
                if (this.isEmpty(mx, my) && this.isEmpty(mx, my - 1)) {
                    const humanId = this.nextHumanId++;
                    this.set(mx, my, MATERIAL.HUMAN_BODY);
                    this.set(mx, my - 1, MATERIAL.HUMAN_HEAD);
                    
                    this.humans.push({
                        id: humanId,
                        headX: mx,
                        headY: my - 1,
                        bodyX: mx,
                        bodyY: my,
                        alive: true,
                        vx: 0,
                        vy: 0,
                        direction: Math.random() < 0.5 ? -1 : 1,
                        justBuilt: false,
                        isBuilder: false
                    });
                }
            }

            // Spawn human feces (attracts flies)
            spawnFeces() {
                this.spawnMaterial(MATERIAL.FEECES);
            }

            // Spawn a fly (or several) - life form attracted to feces
            spawnFly() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const count = Math.floor(Math.random() * 3) + 2; // 2-4 flies
                for (let i = 0; i < count; i++) {
                    const offsetX = Math.floor(Math.random() * 7) - 3;
                    const offsetY = Math.floor(Math.random() * 7) - 3;
                    const fx = mx + offsetX;
                    const fy = my + offsetY;
                    if (fx >= 0 && fx < GRID_WIDTH && fy >= 0 && fy < GRID_HEIGHT && this.isEmpty(fx, fy)) {
                        this.set(fx, fy, MATERIAL.FLY);
                        this.flies.push({
                            id: this.nextFlyId++,
                            x: fx,
                            y: fy,
                            alive: true
                        });
                    }
                }
            }

            // Spawn a builder human (2 voxels: pink head, yellow shirt) - builds at edges
            spawnBuilderHuman() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                
                if (this.isEmpty(mx, my) && this.isEmpty(mx, my - 1)) {
                    const humanId = this.nextHumanId++;
                    this.set(mx, my, MATERIAL.HUMAN_BODY_BUILDER);
                    this.set(mx, my - 1, MATERIAL.HUMAN_HEAD);
                    
                    this.humans.push({
                        id: humanId,
                        headX: mx,
                        headY: my - 1,
                        bodyX: mx,
                        bodyY: my,
                        alive: true,
                        vx: 0,
                        vy: 0,
                        direction: Math.random() < 0.5 ? -1 : 1,
                        justBuilt: false,
                        isBuilder: true
                    });
                }
            }

            // Spawn pellets (shotgun spread - 5-7 light projectiles, launched in spread by gunpowder)
            spawnPellets() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const count = 5 + Math.floor(Math.random() * 3);
                const spread = [[0,0], [-1,0], [1,0], [-1,-1], [1,-1], [-2,0], [2,0]];
                for (let i = 0; i < count && i < spread.length; i++) {
                    const [dx, dy] = spread[i];
                    const px = mx + dx, py = my + dy;
                    if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT && this.isEmpty(px, py)) {
                        this.set(px, py, MATERIAL.PELLET);
                        this.pelletBalls.push({
                            id: this.nextPelletId++,
                            cx: px, cy: py, vx: 0, vy: 0
                        });
                    }
                }
            }

            // Spawn a lead ball (sticky cluster, launched by gunpowder, kills humans on impact)
            spawnLeadBall() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const shape = this._leadShape || (this._leadShape = this.getLeadBallShape());
                const allEmpty = shape.every(v => this.isEmpty(mx + v.x, my + v.y));
                if (allEmpty) {
                    for (const v of shape) this.set(mx + v.x, my + v.y, MATERIAL.LEAD);
                    this.leadBalls.push({
                        id: this.nextLeadBallId++,
                        cx: mx,
                        cy: my,
                        voxels: shape,
                        vx: 0,
                        vy: 0
                    });
                }
            }

            // Spawn glue metal (sticky metal - adjacent blocks won't fall)
            spawnGlueMetal() {
                this.spawnMaterial(MATERIAL.GLUE_METAL);
            }

            // Spawn a worm (1 pink moving particle)
            spawnWorm() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                if (this.isEmpty(mx, my)) {
                    this.set(mx, my, MATERIAL.WORM);
                    this.worms.push({ id: this.nextWormId++, x: mx, y: my });
                }
            }

            // Count active particles
            countParticles() {
                this.particleCount = this.grid.filter(m => m !== MATERIAL.EMPTY).length;
            }

            // Update game state
            update() {
                this.simulate();

                // FPS counter
                this.frameCount++;
                const now = Date.now();
                if (now - this.lastFpsUpdate > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
            }

            // Render the game
            render() {
                // CLEAR EVERYTHING - no trails, no artifacts
                ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
                
                // Sky background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.height);
                gradient.addColorStop(0, '#87ceeb');
                gradient.addColorStop(1, '#b8d8eb');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);

                // Plant color palette: 0=green, 1=brown, 2=yellow, 3=red, 4=pink, 5=orange, 6=magenta
                const PLANT_COLORS = [
                    [34, 139, 34],   // 0: forest green (leaves)
                    [139, 90, 43],   // 1: saddle brown (stems)
                    [255, 255, 0],   // 2: yellow (flower)
                    [255, 80, 80],   // 3: coral red (flower)
                    [255, 182, 193], // 4: light pink (flower)
                    [255, 165, 0],   // 5: orange (flower)
                    [255, 0, 255]    // 6: magenta (flower)
                ];

                const t = Date.now();
                const ps = CONFIG.pixelSize;
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const material = this.get(x, y);
                        if (material === MATERIAL.EMPTY) continue;

                        const props = MATERIAL_PROPS[material];
                        let base = props.shadeBase;
                        if (material === MATERIAL.PLANT) {
                            const pType = this.plantType[this.getIndex(x, y)] || 0;
                            base = PLANT_COLORS[Math.min(pType, 6)];
                        }

                        const hasTop = !this.isEmpty(x, y - 1);
                        const hasBottom = !this.isEmpty(x, y + 1);
                        const hasLeft = !this.isEmpty(x - 1, y);
                        const hasRight = !this.isEmpty(x + 1, y);

                        let shade = 0;
                        if (!hasTop) shade += 20;
                        if (!hasLeft) shade += 10;
                        if (hasBottom && !hasTop) shade += 8;
                        if (!hasRight) shade -= 10;
                        if (!hasBottom) shade -= 15;

                        let noise = (((x * 31 + y * 17) % 101) / 101 - 0.5) * 12;
                        if (material === MATERIAL.LAVA) noise += Math.sin(t * 0.003 + x * 0.5 + y * 0.5) * 15;
                        else if (material === MATERIAL.ACID) noise += Math.sin(t * 0.008 + x + y) * 25;
                        else if (material === MATERIAL.FIRE) noise += Math.sin(t * 0.01 + x + y * 2) * 40;
                        else if (material === MATERIAL.SLIME) noise += Math.sin(t * 0.002 + x * 0.3 + y * 0.3) * 10;
                        else if (material === MATERIAL.EMBER) noise += Math.sin(t * 0.012 + x + y * 2) * 35;
                        else if (material === MATERIAL.HONEY) noise += Math.sin(x * 0.4 + y * 0.6) * 8;
                        else if (material === MATERIAL.FLY) noise += Math.sin(t * 0.02 + x * 2 + y * 2) * 15;
                        else if (material === MATERIAL.WORM) noise += Math.sin(t * 0.025 + x * 1.5 + y * 1.5) * 12;
                        else if (material === MATERIAL.MERCURY) noise += Math.sin(t * 0.002 + x * 0.6 + y * 0.6) * 18;
                        else if (material === MATERIAL.ANTIMATTER) noise += Math.sin(t * 0.004 + x * 0.5 + y * 0.5) * 20;
                        else if (material === MATERIAL.ANTIMATTER_BLAST) {
                            noise += Math.sin(t * 0.015 + x + y * 2) * 45;
                            // Purple-blue variation based on position
                            base = (base[0] + Math.sin(x * 0.3 + y * 0.2) * 40 > 128) ? [160, 60, 255] : [80, 100, 255];
                        }
                        else if (material === MATERIAL.BACTERIA) noise += Math.sin(t * 0.015 + x * 2 + y * 2) * 8;
                        else if (material === MATERIAL.PLANT) {
                            const pType = this.plantType[this.getIndex(x, y)] || 0;
                            noise += pType >= 2 ? Math.sin(x * 0.5 + y * 0.8) * 8
                                : Math.sin(x * 0.7 + y * 1.3) * 15 + Math.cos(x * 1.1 + y * 0.9) * 10;
                        }

                        const r = Math.max(0, Math.min(255, base[0] + shade + noise));
                        const g = Math.max(0, Math.min(255, base[1] + shade + noise));
                        const b = Math.max(0, Math.min(255, base[2] + shade + noise));

                        let fillStyle = material === MATERIAL.STEAM ? `rgba(${r},${g},${b},0.5)` : `rgb(${r},${g},${b})`;
                        if (material === MATERIAL.ANTIMATTER_BLAST) fillStyle = `rgba(${r},${g},${b},0.85)`;
                        ctx.fillStyle = fillStyle;
                        ctx.fillRect(x * ps, y * ps, ps, ps);
                    }
                }

                // Draw SINGLE custom cursor - ONLY when mouse is actually in canvas
                if (this.mouse.isInCanvas) {
                    const mx = this.mouse.x;
                    const my = this.mouse.y;
                    
                    // Outer circle
                    ctx.strokeStyle = this.mouse.down ? 'rgba(255, 80, 80, 0.9)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(mx, my, CONFIG.destroyRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Crosshair lines
                    ctx.strokeStyle = this.mouse.down ? 'rgba(255, 80, 80, 0.8)' : 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    const crossSize = 10;
                    ctx.beginPath();
                    ctx.moveTo(mx - crossSize, my);
                    ctx.lineTo(mx + crossSize, my);
                    ctx.moveTo(mx, my - crossSize);
                    ctx.lineTo(mx, my + crossSize);
                    ctx.stroke();
                    
                    // Center dot
                    ctx.fillStyle = this.mouse.down ? 'rgba(255, 60, 60, 0.9)' : 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(mx, my, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Update UI
                this.countParticles();
                document.getElementById('particleCount').textContent = this.particleCount.toLocaleString();
                const destruction = this.initialParticles > 0 
                    ? Math.floor((1 - this.particleCount / this.initialParticles) * 100)
                    : 0;
                document.getElementById('destructionPercent').textContent = Math.max(0, destruction);
                document.getElementById('fps').textContent = this.fps;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
        }

        // Initialize game
        const game = new Game();
        game.generateBuildings();
        
        // UI visibility state
        let uiVisible = true;

        // Input handling
        window.addEventListener('keydown', (e) => {
            // Rebuild
            if (e.key === 'r' || e.key === 'R') {
                game.grid.fill(MATERIAL.EMPTY);
                game.humanBuiltBlocks.fill(false); // Clear sticky blocks
                game.plantType.fill(0); // Clear plant colors
                game.humans = []; // Clear all humans
                game.nextHumanId = 0;
                game.flies = [];
                game.nextFlyId = 0;
                game.leadBalls = [];
                game.nextLeadBallId = 0;
                game.pelletBalls = [];
                game.nextPelletId = 0;
                game.worms = [];
                game.nextWormId = 0;
                game.generateBuildings();
            }
            
            // Toggle UI visibility
            if (e.key === 'h' || e.key === 'H') {
                uiVisible = !uiVisible;
                const uiElement = document.getElementById('ui');
                const controlsElement = document.getElementById('controls');
                const settingsElement = document.getElementById('settings');
                const indicator = document.getElementById('uiToggleIndicator');
                
                if (uiVisible) {
                    uiElement.classList.remove('hidden');
                    controlsElement.classList.remove('hidden');
                    settingsElement.classList.remove('hidden');
                    indicator.classList.remove('visible');
                } else {
                    uiElement.classList.add('hidden');
                    controlsElement.classList.add('hidden');
                    settingsElement.classList.add('hidden');
                    indicator.classList.add('visible');
                }
            }

            // Spawn materials
            if (e.key === '1') game.spawnMaterial(MATERIAL.CONCRETE);
            if (e.key === '2') game.spawnMaterial(MATERIAL.DUST);
            if (e.key === '3') game.spawnMaterial(MATERIAL.LIQUID);
            if (e.key === '4') game.spawnMaterial(MATERIAL.METAL);
            if (e.key === '5') game.spawnMaterial(MATERIAL.LAVA);
            if (e.key === '6') game.spawnMaterial(MATERIAL.ACID);
            if (e.key === '7') game.spawnHuman(); // Normal human (blue)
            if (e.key === 'b' || e.key === 'B') game.spawnBuilderHuman(); // Builder human (yellow shirt)
            
            // New materials
            if (e.key === '8') game.spawnMaterial(MATERIAL.SNOW);
            if (e.key === '9') game.spawnMaterial(MATERIAL.OIL);
            if (e.key === '0') game.spawnMaterial(MATERIAL.STEAM);
            if (e.key === 'q' || e.key === 'Q') game.spawnMaterial(MATERIAL.BLOOD);
            if (e.key === 'w' || e.key === 'W') game.spawnMaterial(MATERIAL.SLIME);
            if (e.key === 'e' || e.key === 'E') game.spawnMaterial(MATERIAL.FIRE);
            if (e.key === 't' || e.key === 'T') game.spawnPlant(); // Spawn small seeds that grow
            if (e.key === 'y' || e.key === 'Y') game.spawnMaterial(MATERIAL.ICE);
            if (e.key === 'u' || e.key === 'U') game.spawnMaterial(MATERIAL.SAND);
            
            if (e.key === 'i' || e.key === 'I') game.spawnMaterial(MATERIAL.HONEY);
            if (e.key === 'o' || e.key === 'O') game.spawnMaterial(MATERIAL.GRAVEL);
            if (e.key === 'p' || e.key === 'P') game.spawnMaterial(MATERIAL.WOOD);
            if (e.key === 'g' || e.key === 'G') game.spawnMaterial(MATERIAL.GUNPOWDER);
            if (e.key === 'j' || e.key === 'J') game.spawnMaterial(MATERIAL.STONE);
            if (e.key === 'k' || e.key === 'K') game.spawnMaterial(MATERIAL.EMBER);
            if (e.key === 'v' || e.key === 'V') game.spawnMaterial(MATERIAL.LEAD_BRICK);
            if (e.key === 'f' || e.key === 'F') game.spawnFeces();
            if (e.key === 'l' || e.key === 'L') game.spawnFly();
            if (e.key === 'm' || e.key === 'M') game.spawnLeadBall();
            if (e.key === 'n' || e.key === 'N') game.spawnGlueMetal();
            if (e.key === 'z' || e.key === 'Z') game.spawnMaterial(MATERIAL.MILK);
            if (e.key === 'x' || e.key === 'X') game.spawnWorm();
            if (e.key === 'c' || e.key === 'C') game.spawnMaterial(MATERIAL.BACTERIA);
            if (e.key === 'd' || e.key === 'D') game.spawnMaterial(MATERIAL.MERCURY);
            if (e.key === 'a' || e.key === 'A') game.spawnPellets();
            if (e.key === 's' || e.key === 'S') game.spawnMaterial(MATERIAL.FUSE);
            if (e.key === '.' || e.key === '>') game.spawnMaterial(MATERIAL.RUBBER);
            if (e.key === '`' || e.key === '~') game.spawnMaterial(MATERIAL.ANTIMATTER);
        });

        // Voxel size slider
        const voxelSizeSlider = document.getElementById('voxelSizeSlider');
        const voxelSizeDisplay = document.getElementById('voxelSizeDisplay');
        
        voxelSizeSlider.addEventListener('input', (e) => {
            const newSize = parseInt(e.target.value);
            CONFIG.pixelSize = newSize;
            voxelSizeDisplay.textContent = newSize + 'mm';
            
            // Recalculate grid dimensions
            GRID_WIDTH = Math.floor(CONFIG.width / CONFIG.pixelSize);
            GRID_HEIGHT = Math.floor(CONFIG.height / CONFIG.pixelSize);
            
            // FULL RESET: Clear everything and rebuild from scratch
            game._simOrder = null;
            game.grid = new Array(GRID_WIDTH * GRID_HEIGHT).fill(MATERIAL.EMPTY);
            game.velocityX = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.velocityY = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.particleAge = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.humanBuiltBlocks = new Array(GRID_WIDTH * GRID_HEIGHT).fill(false);
            game.plantType = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.particleCount = 0;
            game.initialParticles = 0;
            game.humans = []; // Clear all humans
            game.nextHumanId = 0;
            game.flies = [];
            game.nextFlyId = 0;
            game.leadBalls = [];
            game.nextLeadBallId = 0;
            game.worms = [];
            game.nextWormId = 0;
            
            // Generate new buildings
            game.generateBuildings();
        });

        // Place amount slider (how many voxels when placing materials)
        const placeAmountSlider = document.getElementById('placeAmountSlider');
        const placeAmountDisplay = document.getElementById('placeAmountDisplay');
        
        placeAmountSlider.addEventListener('input', (e) => {
            const newRadius = parseInt(e.target.value);
            CONFIG.spawnRadius = newRadius;
            placeAmountDisplay.textContent = newRadius;
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scale = Math.min(rect.width / CONFIG.width, rect.height / CONFIG.height);
            const offsetX = (rect.width - CONFIG.width * scale) / 2;
            const offsetY = (rect.height - CONFIG.height * scale) / 2;
            const dx = e.clientX - rect.left - offsetX;
            const dy = e.clientY - rect.top - offsetY;
            game.mouse.x = (dx / scale);
            game.mouse.y = (dy / scale);
            game.mouse.isInCanvas = dx >= 0 && dx <= CONFIG.width * scale && dy >= 0 && dy <= CONFIG.height * scale;
        });

        canvas.addEventListener('mouseenter', (e) => {
            e.preventDefault();
            game.mouse.isInCanvas = true;
        });

        canvas.addEventListener('mouseleave', (e) => {
            e.preventDefault();
            game.mouse.isInCanvas = false;
            game.mouse.down = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault(); // Prevent default click behavior
            game.mouse.down = true;
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault(); // Prevent default click behavior
            game.mouse.down = false;
        });

        // Global mouseup to catch releases outside canvas
        window.addEventListener('mouseup', (e) => {
            game.mouse.down = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent right-click menu
        });

        // Continuous destruction while mouse held
        setInterval(() => {
            if (game.mouse.down) {
                game.destroyAtMouse();
            }
        }, 30);

        // Game loop
        function gameLoop() {
            game.update();
            game.render();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
