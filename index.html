<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAMPAGE: VOXEL FURY üß±üí•</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', monospace;
            background: #2a2a2a;
            color: #fff;
            overflow: hidden;
            margin: 0;
            width: 100vw;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 3px solid;
            border-color: #555 #222 #222 #555;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #87ceeb;
            cursor: none !important;
        }

        #gameCanvas * {
            cursor: none !important;
        }

        #settings input[type="range"] {
            cursor: pointer !important;
        }

        #gameContainer {
            cursor: none !important;
        }

        #ui {
            position: absolute;
            top: 12px;
            left: 12px;
            background: #1a1a1a;
            border: 3px solid;
            border-color: #333 #555 #555 #333;
            font-size: 10px;
            line-height: 1.8;
            pointer-events: auto;
            cursor: default;
            min-width: 160px;
        }
        
        #ui.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        #uiHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            cursor: pointer;
            user-select: none;
            border-bottom: 3px solid #555;
        }
        
        #uiHeader:hover {
            background: #2a2a2a;
        }
        
        #ui.collapsed #uiHeader {
            border-bottom: none;
        }
        
        #ui #uiHeader h1 {
            font-size: 10px;
            margin: 0;
            color: #cc8888;
        }
        
        #uiContent {
            padding: 8px 10px 10px 10px;
        }
        
        #ui.collapsed #uiContent {
            display: none;
        }
        
        #uiCollapseBtn {
            font-size: 12px;
            color: #999;
            cursor: pointer;
            padding: 2px 6px;
        }
        
        #uiCollapseBtn:hover {
            color: #ccc;
        }

        #ui .stat {
            margin: 5px 0;
            color: #ddd;
        }

        #ui .label {
            color: #999;
        }

        #materialMenu {
            position: absolute;
            bottom: 0;
            cursor: default;
            left: 50%;
            transform: translateX(-50%);
            max-width: 95%;
            background: #1a1a1a;
            border: 3px solid;
            border-color: #333 #555 #555 #333;
            border-bottom: none;
            pointer-events: auto;
            min-width: 200px;
        }
        
        #materialMenu.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        #materialMenuHeader {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            cursor: pointer;
            user-select: none;
            border-bottom: 3px solid #555;
            min-height: 36px;
        }
        
        #materialMenuHeader:hover {
            background: #2a2a2a;
        }
        
        #materialDragHandle {
            padding: 4px 8px;
            margin: -4px 4px -4px -4px;
            font-size: 12px;
            color: #666;
            cursor: grab;
            user-select: none;
        }
        #materialDragHandle:active {
            cursor: grabbing;
        }
        #materialDragHandle:hover {
            color: #888;
        }
        #materialDestroyBtn {
            padding: 4px 8px;
            margin: -4px 4px -4px 0;
            font-size: 8px;
            color: #888;
            cursor: pointer;
            user-select: none;
            border: 2px solid;
            border-color: #555 #333 #333 #555;
        }
        #materialDestroyBtn:hover {
            color: #cc8888;
            border-color: #666 #444 #444 #666;
        }
        #materialDestroyBtn.active {
            color: #cc8888;
            background: #333;
            border-color: #333 #555 #555 #333;
        }
        #materialTabs {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        
        #materialTabs .tab {
            padding: 6px 10px;
            font-size: 8px;
            font-weight: bold;
            color: #999;
            background: #2a2a2a;
            border: 2px solid;
            border-color: #555 #333 #333 #555;
            cursor: pointer;
        }
        
        #materialTabs .tab:hover {
            color: #ccc;
            background: #333;
            border-color: #666 #444 #444 #666;
        }
        
        #materialTabs .tab.active {
            color: #ccc;
            background: #333;
            border-color: #333 #555 #555 #555;
        }
        
        #materialContent {
            padding: 12px 16px 16px;
            max-height: 160px;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        #materialMenu.minimized #materialContent {
            display: none;
        }
        
        .materialTile {
            width: 40px;
            height: 40px;
            border: 2px solid;
            border-color: #555 #333 #333 #555;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 7px;
            color: #fff;
            flex-shrink: 0;
        }
        
        .materialTile:hover {
            border-color: #666 #444 #444 #666;
            background: #2a2a2a;
        }
        
        .materialTile.selected {
            border-color: #cc8888 #664444 #664444 #cc8888;
            background: #333;
        }
        
        .materialTile .tileColor {
            width: 24px;
            height: 18px;
            border: 2px solid;
            border-color: #444 #222 #222 #444;
            margin-bottom: 2px;
        }
        
        .materialTile .tileName {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 6px;
        }
        
        #minimizeBtn {
            margin-left: auto;
            padding: 4px 8px;
            font-size: 8px;
            color: #888;
            cursor: pointer;
            border: 2px solid;
            border-color: #555 #333 #333 #555;
        }
        
        #minimizeBtn:hover {
            color: #ccc;
            background: #333;
            border-color: #666 #444 #444 #666;
        }
        
        #currentMaterialDisplay {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: #1a1a1a;
            padding: 8px 12px;
            font-size: 8px;
            color: #fff;
            border: 3px solid;
            border-color: #333 #555 #555 #333;
            pointer-events: none;
        }
        
        #currentMaterialDisplay.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        #currentMaterialDisplay .swatch {
            width: 24px;
            height: 24px;
            border: 2px solid;
            border-color: #444 #222 #222 #444;
            flex-shrink: 0;
        }
        
        #currentMaterialDisplay .name {
            font-weight: bold;
            color: #999;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #999;
        }

        #settings {
            position: absolute;
            top: 60px;
            right: 12px;
            background: #1a1a1a;
            font-size: 8px;
            line-height: 2;
            border: 3px solid;
            border-color: #333 #555 #555 #333;
            min-width: 220px;
            max-width: 35vw;
            pointer-events: auto;
            cursor: default;
        }
        
        #settings.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        #settings.mainMenuOverlay {
            z-index: 101;
        }
        #settings input[type="text"] {
            width: 100%;
            box-sizing: border-box;
            padding: 6px 8px;
            font-size: 11px;
            background: #222;
            border: 1px solid #444;
            color: #ccc;
        }
        
        #settingsHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            cursor: pointer;
            user-select: none;
            border-bottom: 3px solid #555;
        }
        
        #settingsHeader:hover {
            background: #2a2a2a;
        }
        
        #settings.collapsed #settingsHeader {
            border-bottom: none;
        }
        
        #settingsContent {
            padding: 8px 12px 12px 12px;
        }
        
        #settings.collapsed #settingsContent {
            display: none;
        }
        
        #settingsCollapseBtn {
            font-size: 12px;
            color: #999;
            cursor: pointer;
            padding: 2px 6px;
        }
        
        #settingsCollapseBtn:hover {
            color: #ccc;
        }

        #settings h3 {
            font-size: 8px;
            margin: 0;
            color: #999;
        }

        .setting-item {
            margin: 10px 0;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            color: #999;
            font-size: 8px;
            white-space: nowrap;
            overflow: visible;
        }

        .setting-item input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .setting-value {
            color: #ddd;
            font-weight: bold;
            font-size: 8px;
        }

        .setting-note {
            color: #666;
            font-size: 7px;
            margin-top: 3px;
        }
        
        #uiToggleIndicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #1a1a1a;
            color: #999;
            padding: 8px 10px;
            font-size: 7px;
            line-height: 2;
            border: 3px solid;
            border-color: #333 #555 #555 #333;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        
        #uiToggleIndicator.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Main Menu / Gamemode Selector */
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }
        #mainMenu.hidden {
            display: none;
        }
        #mainMenu h1 {
            font-size: 36px;
            color: #cc8888;
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px #000;
        }
        #mainMenu p {
            color: #999;
            font-size: 14px;
            margin-bottom: 32px;
        }
        #mainMenuButtons {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .modeBtn {
            padding: 20px 40px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            background: #333;
            border: 2px solid #555;
            cursor: pointer;
            min-width: 160px;
        }
        .modeBtn:hover {
            background: #444;
            border-color: #888;
        }
        .modeBtn.sandbox { border-color: #4a9eff; }
        .modeBtn.sandbox:hover { background: #2a4a6a; }
        .modeBtn.survival { border-color: #ff6b6b; }
        .modeBtn.survival:hover { background: #6a2a2a; }
        #mainMenuSettingsBtn {
            margin-top: 16px;
            padding: 8px 16px;
            font-size: 12px;
            color: #999;
            background: transparent;
            border: 1px solid #555;
            cursor: pointer;
        }
        #mainMenuSettingsBtn:hover { color: #ccc; border-color: #777; }

        /* Survival UI */
        #survivalUI {
            position: absolute;
            top: 12px;
            left: 160px;
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 10;
            pointer-events: none;
        }
        #survivalUI.hidden {
            display: none;
        }
        #healthBar {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #1a1a1a;
            padding: 6px 12px;
            border: 1px solid #555;
        }
        #healthFill {
            width: 120px;
            height: 16px;
            background: #333;
            border: 1px solid #555;
            overflow: hidden;
        }
        #healthFill .fill {
            height: 100%;
            background: #4ade80;
            transition: width 0.2s, background 0.2s;
        }
        #healthFill .fill.low { background: #fbbf24; }
        #healthFill .fill.critical { background: #ef4444; }
        #inventoryBar {
            display: flex;
            gap: 4px;
            background: #1a1a1a;
            padding: 6px 12px;
            border: 1px solid #555;
            max-width: 400px;
            flex-wrap: wrap;
        }
        .invSlot {
            width: 36px;
            height: 36px;
            border: 1px solid #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
        }
        .invSlot .invColor { width: 20px; height: 14px; border: 1px solid #444; }
        .invSlot .invCount { font-weight: bold; }

        /* Survival: Crafting panel (Tab to open) */
        #craftingPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 480px;
            max-width: 95vw;
            background: #1a1a1a;
            border: 2px solid #555;
            z-index: 50;
            display: none;
            pointer-events: auto;
        }
        #craftingPanel.open { display: block; }
        #craftingPanel h2 { font-size: 16px; color: #ccc; margin: 0 0 12px 0; padding: 12px; border-bottom: 1px solid #555; }
        #craftingGoal { font-size: 12px; }
        #craftingContent { display: flex; gap: 24px; padding: 16px; max-height: 50vh; }
        #craftingInventory { flex: 1; overflow-y: auto; }
        #craftingRecipes { flex: 1; overflow-y: auto; max-height: 45vh; }
        #craftingInventory h3, #craftingRecipes h3 { font-size: 12px; color: #999; margin-bottom: 8px; }
        .craftSlot { display: flex; align-items: center; gap: 8px; padding: 6px 10px; margin: 4px 0; background: #2a2a2a; border: 1px solid #444; cursor: pointer; }
        .craftSlot:hover { border-color: #777; background: #333; }
        .craftSlot.selected { border-color: #4ade80; background: #1a2a1a; }
        .craftSlot .colorBox { width: 20px; height: 20px; border: 1px solid #555; flex-shrink: 0; }
        .craftSlot .name { flex: 1; }
        .craftSlot .count { color: #888; }
        .craftRecipe { display: flex; align-items: center; gap: 8px; padding: 8px; margin: 6px 0; background: #2a2a2a; border: 1px solid #444; cursor: pointer; }
        .craftRecipe:hover { border-color: #777; }
        .craftRecipe.cantCraft { opacity: 0.5; cursor: not-allowed; }
        .craftRecipe .inputs, .craftRecipe .arrow, .craftRecipe .output { display: flex; align-items: center; gap: 4px; }
        .craftRecipe .arrow { color: #666; }
        .craftRecipe .output .colorBox { width: 24px; height: 24px; }
        .craftHint { font-size: 10px; color: #666; margin-top: 12px; padding-top: 8px; border-top: 1px solid #333; }
        #craftingHearts { display: flex; gap: 2px; margin-bottom: 12px; }
        #craftingHearts span { font-size: 18px; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="mainMenu">
            <h1>üß± RAMPAGE: VOXEL FURY üí•</h1>
            <p>Choose your mode</p>
            <div id="mainMenuButtons">
                <button class="modeBtn sandbox">üéÆ Sandbox</button>
                <button class="modeBtn survival">üèïÔ∏è Survival</button>
            </div>
            <button id="mainMenuSettingsBtn" title="Open Settings to type survivalstart for Survival mode">‚öôÔ∏è Settings</button>
        </div>

        <canvas id="gameCanvas"></canvas>
        
        <div id="craftingPanel">
            <h2>‚öíÔ∏è Crafting <span style="color:#666;font-size:11px;">Tab to close</span></h2>
            <div id="craftingGoal"></div>
            <div id="craftingHearts"></div>
            <div id="craftingContent">
                <div id="craftingInventory">
                    <h3>Inventory ‚Äî click to select for placing</h3>
                    <div id="craftingInventoryList"></div>
                    <div class="craftHint">Click inventory or craft to select. LClick=place, RClick or B+LClick=break/dig.</div>
                </div>
                <div id="craftingRecipes">
                    <h3>Recipes</h3>
                    <div id="craftingRecipeList"></div>
                </div>
            </div>
        </div>
        
        <div id="ui">
            <div id="uiHeader">
                <h1>üí• VOXEL FURY üß±</h1>
                <span id="uiCollapseBtn">‚àí</span>
            </div>
            <div id="uiContent">
                <div class="stat"><span class="label">Voxels:</span> <span id="particleCount">0</span></div>
                <div class="stat"><span class="label">Destroyed:</span> <span id="destructionPercent">0</span>%</div>
                <div class="stat"><span class="label">FPS:</span> <span id="fps">60</span></div>
            </div>
        </div>

        <div id="settings" class="hidden">
            <div id="settingsHeader">
                <h3>‚öôÔ∏è Settings</h3>
                <span id="settingsCollapseBtn">‚àí</span>
            </div>
            <div id="settingsContent">
            <div class="setting-item">
                <label>Voxel Size: <span class="setting-value" id="voxelSizeDisplay">3mm</span></label>
                <input type="range" id="voxelSizeSlider" min="2" max="8" value="3" step="1">
                <div class="setting-note">2‚Äì8mm. Smaller = more detail but slower</div>
            </div>
            <div class="setting-item">
                <label>Place Amount: <span class="setting-value" id="placeAmountDisplay">20</span></label>
                <input type="range" id="placeAmountSlider" min="1" max="50" value="20" step="1">
                <div class="setting-note">Radius when placing (1 = single voxel | 50 = large blob)</div>
            </div>
            <div class="setting-item">
                <label>Command:</label>
                <input type="text" id="settingsCommand" placeholder="Type survivalstart to start Survival mode" autocomplete="off">
            </div>
            </div>
        </div>

        <div id="currentMaterialDisplay">
            <div class="swatch" id="currentSwatch"></div>
            <div class="name" id="currentMaterialName">‚Äî</div>
        </div>

        <div id="materialMenu">
            <div id="materialMenuHeader">
                <span id="materialDragHandle" title="Drag to move">‚ãÆ‚ãÆ</span>
                <span id="materialDestroyBtn" title="Destroy mode (left-click destroys)">‚úï</span>
                <div id="materialTabs"></div>
                <span style="font-size:10px;color:#666;margin-left:8px;">R=Rebuild</span>
                <span id="minimizeBtn">‚àí</span>
            </div>
            <div id="materialContent"></div>
        </div>
        
        <div id="uiToggleIndicator">H = show UI | Left-click = place | Right-click = destroy | Shift+drag = draw lines | Spawner = put material inside hollow square | O/C = trapdoors | R = rebuild</div>
    </div>

    <script>
        // ============================================
        // RAMPAGE: VOXEL FURY
        // Pixel-Perfect Destruction Physics Sandbox
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        // Game Configuration
        let CONFIG = {
            width: 1280,
            height: 720,
            pixelSize: 3, // Size of each voxel particle in mm (1-8mm)
            gravity: 0.5,
            destroyRadius: 25,
            spawnRadius: 20 // How many voxels placed when spawning (radius of placement circle)
        };

        // Set canvas size
        canvas.width = CONFIG.width;
        canvas.height = CONFIG.height;

        // Calculate grid dimensions (will be recalculated when voxel size changes)
        let GRID_WIDTH = Math.floor(CONFIG.width / CONFIG.pixelSize);
        let GRID_HEIGHT = Math.floor(CONFIG.height / CONFIG.pixelSize);

        // Material Types
        const MATERIAL = {
            EMPTY: 0,
            CONCRETE: 1,
            METAL: 2,
            GLASS: 3,
            DUST: 4,
            LIQUID: 5,
            LAVA: 6,
            ACID: 7,
            HUMAN_HEAD: 8,
            HUMAN_BODY: 9,           // Normal human - blue shirt, does not build
            HUMAN_BODY_BUILDER: 26,  // Builder human - yellow shirt, builds at edges
            DEAD_HUMAN: 10,  // Red unmoving voxels (acid victims)
            SNOW: 11,        // White particles, accumulate, cold
            OIL: 12,         // Dark liquid, flammable
            STEAM: 13,       // Gas that rises instead of falls
            BLOOD: 14,       // Red liquid
            SLIME: 15,       // Slow viscous liquid
            FIRE: 16,        // Spreads and burns, rises
            PLANT: 17,       // Living material that grows
            ICE: 18,         // Solid that melts into water
            SAND: 19,        // Fast-falling particles
            HONEY: 20,       // Very viscous golden liquid
            GRAVEL: 21,      // Heavy fast-falling particles
            WOOD: 22,        // Burnable solid
            GUNPOWDER: 23,   // Explosive particles
            STONE: 24,       // Heavy solid, rugged
            EMBER: 25,       // Hot glowing particles that rise
            FEECES: 27,      // Brown solid, attracts flies
            FLY: 28,         // Life form - buzzes toward feces
            LEAD: 29,        // Heavy ball - sticks together, launched by gunpowder, kills humans on impact
            GLUE_METAL: 30,  // Sticky metal - adjacent blocks won't fall (like slime/honey)
            MILK: 31,        // White liquid - flows like water
            WORM: 32,        // Life form - 1 pink moving particle
            LEAD_BRICK: 33,  // Like concrete but immune to lead ball destruction
            BACTERIA: 34,    // Life form - reproduces near nutrients, dies from heat/acid
            MERCURY: 35,     // Dense liquid metal - sinks through other liquids, toxic
            PELLET: 36,      // Light shot - small, launched in spread for shotgun contraptions
            FUSE: 37,        // Burnable solid - carries fire along its length for chain ignition
            RUBBER: 38,      // Bouncy block - deflects lead and pellets
            ANTIMATTER: 39,  // Purple powder - ignite with fire for purple/blue blast!
            ANTIMATTER_BLAST: 40,  // Purple-blue blast from antimatter explosion (rises, destroys)
            ANTIMETAL: 41,  // Dense metal - blocks antimatter blast (immune to vaporization)
            TRAPDOOR: 42,   // Opens with O, closes with C - things fall through when open
            WATER_SPOUT: 43,  // Emits water downward - build fountains & fill areas
            LAVA_SPOUT: 44,   // Emits lava downward - build lava flows
            PLAYER_HEAD: 45,   // Survival mode: player entity (controlled by arrow keys)
            PLAYER_BODY: 46   // Survival mode: player entity body
        };

        // Material Properties
        const MATERIAL_PROPS = {
            [MATERIAL.EMPTY]: { color: null, density: 0, strength: 0 },
            [MATERIAL.CONCRETE]: { color: '#5a6268', density: 8, strength: 5, flow: false, shadeBase: [90, 98, 104] },
            [MATERIAL.METAL]: { color: '#8899aa', density: 10, strength: 8, flow: false, shadeBase: [136, 153, 170] },
            [MATERIAL.GLASS]: { color: '#4a9eff', density: 4, strength: 2, flow: false, shadeBase: [74, 158, 255] },
            [MATERIAL.DUST]: { color: '#c4a574', density: 2, strength: 0, flow: true, shadeBase: [196, 165, 116] },
            [MATERIAL.LIQUID]: { color: '#2563eb', density: 3, strength: 0, flow: true, shadeBase: [37, 99, 235] },
            [MATERIAL.LAVA]: { color: '#ff4500', density: 6, strength: 0, flow: true, shadeBase: [255, 69, 0], glows: true },
            [MATERIAL.ACID]: { color: '#00ff41', density: 2, strength: 0, flow: true, shadeBase: [0, 255, 65], corrosive: true },
            [MATERIAL.HUMAN_HEAD]: { color: '#ff69b4', density: 5, strength: 3, flow: false, shadeBase: [255, 105, 180], isHuman: true },
            [MATERIAL.HUMAN_BODY]: { color: '#4169e1', density: 5, strength: 3, flow: false, shadeBase: [65, 105, 225], isHuman: true },
            [MATERIAL.HUMAN_BODY_BUILDER]: { color: '#ffd700', density: 5, strength: 3, flow: false, shadeBase: [255, 215, 0], isHuman: true },
            [MATERIAL.DEAD_HUMAN]: { color: '#ff0000', density: 100, strength: 0, flow: false, shadeBase: [255, 0, 0], static: true },
            [MATERIAL.SNOW]: { color: '#ffffff', density: 1, strength: 0, flow: true, shadeBase: [255, 255, 255], cold: true },
            [MATERIAL.OIL]: { color: '#2d2d2d', density: 2, strength: 0, flow: true, shadeBase: [45, 45, 45], flammable: true },
            [MATERIAL.STEAM]: { color: '#e8e8e8', density: 0.5, strength: 0, flow: true, shadeBase: [232, 232, 232], rises: true },
            [MATERIAL.BLOOD]: { color: '#8b0000', density: 3, strength: 0, flow: true, shadeBase: [139, 0, 0] },
            [MATERIAL.SLIME]: { color: '#32cd32', density: 4, strength: 0, flow: true, shadeBase: [50, 205, 50], viscous: true },
            [MATERIAL.FIRE]: { color: '#ff8c00', density: 0.3, strength: 0, flow: true, shadeBase: [255, 140, 0], burns: true, rises: true },
            [MATERIAL.PLANT]: { color: '#228b22', density: 3, strength: 2, flow: false, shadeBase: [34, 139, 34], grows: true },
            [MATERIAL.ICE]: { color: '#add8e6', density: 5, strength: 3, flow: false, shadeBase: [173, 216, 230], melts: true },
            [MATERIAL.SAND]: { color: '#f4a460', density: 4, strength: 0, flow: true, shadeBase: [244, 164, 96] },
            [MATERIAL.HONEY]: { color: '#daa520', density: 5, strength: 0, flow: true, shadeBase: [218, 165, 32], viscous: true },
            [MATERIAL.GRAVEL]: { color: '#6b6b6b', density: 6, strength: 0, flow: true, shadeBase: [107, 107, 107] },
            [MATERIAL.WOOD]: { color: '#8b4513', density: 5, strength: 4, flow: false, shadeBase: [139, 69, 19], flammable: true },
            [MATERIAL.GUNPOWDER]: { color: '#3d3d3d', density: 3, strength: 0, flow: true, shadeBase: [61, 61, 61], explosive: true },
            [MATERIAL.STONE]: { color: '#696969', density: 9, strength: 6, flow: false, shadeBase: [105, 105, 105] },
            [MATERIAL.EMBER]: { color: '#ff6b35', density: 0.4, strength: 0, flow: true, shadeBase: [255, 107, 53], rises: true },
            [MATERIAL.FEECES]: { color: '#5d4037', density: 4, strength: 1, flow: false, shadeBase: [93, 64, 55], attractsFlies: true },
            [MATERIAL.FLY]: { color: '#1a1a1a', density: 0.2, strength: 0, flow: false, shadeBase: [26, 26, 26], isFly: true },
            [MATERIAL.LEAD]: { color: '#36454f', density: 12, strength: 6, flow: false, shadeBase: [54, 69, 79], isLead: true },
            [MATERIAL.GLUE_METAL]: { color: '#708090', density: 7, strength: 4, flow: false, shadeBase: [112, 128, 144], sticky: true },
            [MATERIAL.MILK]: { color: '#f5f5dc', density: 3, strength: 0, flow: true, shadeBase: [245, 245, 220] },
            [MATERIAL.WORM]: { color: '#ff69b4', density: 0.3, strength: 0, flow: false, shadeBase: [255, 105, 180], isWorm: true },
            [MATERIAL.LEAD_BRICK]: { color: '#3d4f5c', density: 9, strength: 6, flow: false, shadeBase: [61, 79, 92] },
            [MATERIAL.BACTERIA]: { color: '#7cfc00', density: 1, strength: 0, flow: false, shadeBase: [124, 252, 0], grows: true },
            [MATERIAL.MERCURY]: { color: '#b8b8b8', density: 14, strength: 0, flow: true, shadeBase: [184, 184, 184], toxic: true },
            [MATERIAL.PELLET]: { color: '#8b7355', density: 4, strength: 2, flow: false, shadeBase: [139, 115, 85], isPellet: true },
            [MATERIAL.FUSE]: { color: '#4a3728', density: 2, strength: 1, flow: false, shadeBase: [74, 55, 40], flammable: true, isFuse: true, static: true },
            [MATERIAL.RUBBER]: { color: '#2d2d2d', density: 3, strength: 3, flow: false, shadeBase: [45, 45, 50], bouncy: true },
            [MATERIAL.ANTIMATTER]: { color: '#8b008b', density: 3, strength: 0, flow: true, shadeBase: [139, 0, 139], explosive: true },
            [MATERIAL.ANTIMATTER_BLAST]: { color: '#8a2be2', density: 0.3, strength: 0, flow: true, shadeBase: [120, 80, 255], burns: true, rises: true },
            [MATERIAL.ANTIMETAL]: { color: '#2a2a3a', density: 12, strength: 10, flow: false, shadeBase: [42, 42, 58], blocksAntimatter: true },
            [MATERIAL.TRAPDOOR]: { color: '#4a3728', density: 8, strength: 5, flow: false, shadeBase: [74, 55, 40], isTrapdoor: true, sticky: true },
            [MATERIAL.WATER_SPOUT]: { color: '#6eb5d0', density: 6, strength: 4, flow: false, shadeBase: [110, 181, 208], isSpout: true, spoutLiquid: MATERIAL.LIQUID },
            [MATERIAL.LAVA_SPOUT]: { color: '#d94a2e', density: 7, strength: 5, flow: false, shadeBase: [217, 74, 46], isSpout: true, spoutLiquid: MATERIAL.LAVA, glows: true },
            [MATERIAL.PLAYER_HEAD]: { color: '#00ff88', density: 5, strength: 5, flow: false, shadeBase: [0, 255, 136], isPlayer: true },
            [MATERIAL.PLAYER_BODY]: { color: '#00cc6a', density: 5, strength: 5, flow: false, shadeBase: [0, 204, 106], isPlayer: true }
        };

        // Material display names
        const MATERIAL_LABELS = {
            [MATERIAL.CONCRETE]: 'Concrete', [MATERIAL.METAL]: 'Metal', [MATERIAL.GLASS]: 'Glass', [MATERIAL.DUST]: 'Dust',
            [MATERIAL.LIQUID]: 'Water', [MATERIAL.LAVA]: 'Lava', [MATERIAL.ACID]: 'Acid', [MATERIAL.SNOW]: 'Snow',
            [MATERIAL.OIL]: 'Oil', [MATERIAL.STEAM]: 'Steam', [MATERIAL.BLOOD]: 'Blood', [MATERIAL.SLIME]: 'Slime',
            [MATERIAL.FIRE]: 'Fire', [MATERIAL.PLANT]: 'Plant', [MATERIAL.ICE]: 'Ice', [MATERIAL.SAND]: 'Sand',
            [MATERIAL.HONEY]: 'Honey', [MATERIAL.GRAVEL]: 'Gravel', [MATERIAL.WOOD]: 'Wood', [MATERIAL.GUNPOWDER]: 'Gunpowder',
            [MATERIAL.STONE]: 'Stone', [MATERIAL.EMBER]: 'Ember', [MATERIAL.FEECES]: 'Feces', [MATERIAL.LEAD]: 'Lead Ball',
            [MATERIAL.GLUE_METAL]: 'Glue Metal', [MATERIAL.MILK]: 'Milk', [MATERIAL.WORM]: 'Worm',
            [MATERIAL.LEAD_BRICK]: 'Lead Brick', [MATERIAL.BACTERIA]: 'Bacteria', [MATERIAL.MERCURY]: 'Mercury',
            [MATERIAL.PELLET]: 'Pellets', [MATERIAL.FUSE]: 'Fuse', [MATERIAL.RUBBER]: 'Rubber',
            [MATERIAL.ANTIMATTER]: 'Antimatter', [MATERIAL.ANTIMATTER_BLAST]: 'Antimatter Blast',             [MATERIAL.ANTIMETAL]: 'Antimetal',
            [MATERIAL.TRAPDOOR]: 'Trapdoor',
            [MATERIAL.WATER_SPOUT]: 'Water Spout',
            [MATERIAL.LAVA_SPOUT]: 'Lava Spout',
            [MATERIAL.PLAYER_HEAD]: 'You',
            [MATERIAL.PLAYER_BODY]: 'You',
            [MATERIAL.FLY]: 'Flies', [MATERIAL.DEAD_HUMAN]: 'Dead', [MATERIAL.HUMAN_HEAD]: 'Human', [MATERIAL.HUMAN_BODY]: 'Human',
            [MATERIAL.HUMAN_BODY_BUILDER]: 'Builder'
        };

        // Menu tabs: Solid | Liquid | Explosive | Life
        const MATERIAL_TABS = {
            Solid: [
                MATERIAL.CONCRETE, MATERIAL.METAL, MATERIAL.GLASS, MATERIAL.DUST, MATERIAL.SNOW, MATERIAL.ICE,
                MATERIAL.SAND, MATERIAL.GRAVEL, MATERIAL.WOOD, MATERIAL.STONE, MATERIAL.GLUE_METAL,
                MATERIAL.RUBBER, MATERIAL.ANTIMETAL, MATERIAL.FEECES, MATERIAL.FUSE, MATERIAL.EMBER, MATERIAL.TRAPDOOR,
                MATERIAL.WATER_SPOUT, MATERIAL.LAVA_SPOUT
            ],
            Liquid: [
                MATERIAL.LIQUID, MATERIAL.LAVA, MATERIAL.ACID, MATERIAL.OIL, MATERIAL.STEAM, MATERIAL.BLOOD,
                MATERIAL.SLIME, MATERIAL.HONEY, MATERIAL.MILK, MATERIAL.MERCURY
            ],
            Explosive: [
                MATERIAL.GUNPOWDER, MATERIAL.FIRE, MATERIAL.ANTIMATTER,
                { special: 'leadBall', label: 'Lead Ball', color: '#36454f' }
            ],
            Build: [
                { special: 'spawner', label: 'Spawner', color: '#8b9dc3' },
                { special: 'bridge', label: 'Bridge', color: '#5a6268' },
                { special: 'tower', label: 'Tower', color: '#8899aa' },
                { special: 'arch', label: 'Arch', color: '#696969' },
                { special: 'stairs', label: 'Stairs', color: '#7a8a94' },
                { special: 'wall', label: 'Wall', color: '#6b7b6b' },
                { special: 'platform', label: 'Platform', color: '#8b7355' },
                { special: 'pyramid', label: 'Pyramid', color: '#5a5a5a' },
                { special: 'pillar', label: 'Pillar', color: '#a0a8b0' }
            ],
            Life: [
            { special: 'human', label: 'Human', color: '#ff69b4' },
            { special: 'builder', label: 'Builder', color: '#ffd700' },
            { special: 'plant', label: 'Plant', color: '#228b22' },
            { special: 'flies', label: 'Flies', color: '#1a1a1a' },
            { special: 'worm', label: 'Worm', color: '#ff69b4' },
            { special: 'bacteria', label: 'Bacteria', color: '#7cfc00' },
            { special: 'pellets', label: 'Pellets', color: '#8b7355' }
            ]
        };

        // Game State
        class Game {
            constructor() {
                this.grid = new Array(GRID_WIDTH * GRID_HEIGHT).fill(MATERIAL.EMPTY);
                this.velocityX = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
                this.velocityY = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
                this.particleAge = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0); // Track when debris was created
                this.humanBuiltBlocks = new Array(GRID_WIDTH * GRID_HEIGHT).fill(false); // Track blocks placed by humans (sticky)
                this.plantType = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0); // 0=green leaf, 1=brown stem, 2+=flower colors
                this.mouse = { x: -1000, y: -1000, down: false, rightDown: false, isInCanvas: false }; // left=place, right=destroy
                this.particleCount = 0;
                this.initialParticles = 0;
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.humans = []; // Track human entities (each human is 2 voxels)
                this.nextHumanId = 0;
                this.flies = [];  // Track fly entities (1 voxel each)
                this.nextFlyId = 0;
                this.leadBalls = []; // Track lead balls (connected voxel clusters)
                this.nextLeadBallId = 0;
                this.pelletBalls = []; // Track pellet shots (small projectiles, spread launch)
                this.nextPelletId = 0;
                this.worms = []; // Track worm entities (1 pink particle each)
                this.nextWormId = 0;
                this.trapdoorIndices = new Set(); // Grid indices where trapdoors exist (O=open all, C=close all)
                this.spoutIndices = new Map();   // idx -> liquid (LIQUID or LAVA) for spouts that emit
                this.spawnerStructures = [];     // { left, top, right, bottom, emitX, emitY, material } - hollow square, emits what's inside
                this.undoHistory = [];           // Stack of { type: 'place'|'destroy', changes: [...] }
                this.maxUndoHistory = 50;        // Limit memory usage
                this.gameMode = 'sandbox';
                this.player = null;
                this.inventory = {};
                this.playerKeys = { up: false, down: false, left: false, right: false };
                this.blocksPlaced = 0;
            }

            // Capture current cell state for undo
            captureCellState(x, y) {
                const idx = this.getIndex(x, y);
                if (idx < 0) return null;
                const material = this.grid[idx];
                const state = { x, y, prevMaterial: material };
                if (material === MATERIAL.PLANT) state.prevPlantType = this.plantType[idx];
                state.prevHumanBuilt = this.humanBuiltBlocks[idx];
                if (material === MATERIAL.TRAPDOOR) state.wasTrapdoor = true;
                if (material === MATERIAL.WATER_SPOUT || material === MATERIAL.LAVA_SPOUT) {
                    state.wasSpout = true;
                    state.spoutLiquid = material === MATERIAL.WATER_SPOUT ? MATERIAL.LIQUID : MATERIAL.LAVA;
                }
                return state;
            }

            // Restore a cell from undo state (for undoing placement or destruction)
            restoreCell(state) {
                const { x, y, prevMaterial, prevPlantType, prevHumanBuilt, wasTrapdoor, wasSpout, spoutLiquid } = state;
                const idx = this.getIndex(x, y);
                if (idx < 0) return;
                this.trapdoorIndices.delete(idx);
                this.spoutIndices.delete(idx);
                this.grid[idx] = prevMaterial;
                if (prevMaterial === MATERIAL.PLANT && prevPlantType !== undefined) this.plantType[idx] = prevPlantType;
                this.humanBuiltBlocks[idx] = prevHumanBuilt || false;
                this.velocityX[idx] = 0;
                this.velocityY[idx] = 0;
                this.particleAge[idx] = 0;
                if (wasTrapdoor) this.trapdoorIndices.add(idx);
                if (wasSpout && spoutLiquid) this.spoutIndices.set(idx, spoutLiquid);
            }

            undo() {
                const action = this.undoHistory.pop();
                if (!action) return;
                for (const change of action.changes) {
                    this.restoreCell(change);
                }
            }

            // Place single voxel (records for undo) - used by line tool start and direct placement
            placeSingle(x, y, material) {
                if (this.gameMode === 'survival') {
                    if (!this.consumeFromInventory(material, 1)) return;
                }
                const state = this.captureCellState(x, y);
                const idx = this.getIndex(x, y);
                if (idx >= 0) {
                    this.grid[idx] = material;
                    if (material === MATERIAL.TRAPDOOR) this.trapdoorIndices.add(idx);
                    if (material === MATERIAL.WATER_SPOUT) this.spoutIndices.set(idx, MATERIAL.LIQUID);
                    if (material === MATERIAL.LAVA_SPOUT) this.spoutIndices.set(idx, MATERIAL.LAVA);
                    this.notifyMaterialPlacedAt(x, y, material);
                    if (this.gameMode === 'survival') this.blocksPlaced = (this.blocksPlaced || 0) + 1;
                    if (state) {
                        this.undoHistory.push({ type: 'place', changes: [state] });
                        if (this.undoHistory.length > this.maxUndoHistory) this.undoHistory.shift();
                    }
                }
            }

            // Reinitialize grid when voxel size changes
            reinitializeGrid() {
                const newSize = GRID_WIDTH * GRID_HEIGHT;
                this.grid = new Array(newSize).fill(MATERIAL.EMPTY);
                this.velocityX = new Array(newSize).fill(0);
                this.velocityY = new Array(newSize).fill(0);
                this.particleAge = new Array(newSize).fill(0);
                this.humanBuiltBlocks = new Array(newSize).fill(false);
                this.plantType = new Array(newSize).fill(0);
                this.humans = []; // Clear all humans
                this.nextHumanId = 0;
                this.flies = [];
                this.nextFlyId = 0;
                this.leadBalls = [];
                this.nextLeadBallId = 0;
                this.pelletBalls = [];
                this.nextPelletId = 0;
                this.worms = [];
                this.nextWormId = 0;
                this.trapdoorIndices = new Set();
                this.spoutIndices = new Map();
                this.spawnerStructures = [];
                this.generateBuildings();
            }

            getIndex(x, y) {
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return -1;
                return Math.floor(y) * GRID_WIDTH + Math.floor(x);
            }

            get(x, y) {
                const idx = this.getIndex(x, y);
                return idx === -1 ? MATERIAL.EMPTY : this.grid[idx];
            }

            set(x, y, material) {
                const idx = this.getIndex(x, y);
                if (idx !== -1) this.grid[idx] = material;
            }

            isEmpty(x, y) {
                return this.get(x, y) === MATERIAL.EMPTY;
            }

            // Check empty in a specific grid (for sim - target cells use newGrid)
            isEmptyIn(grid, x, y) {
                const idx = this.getIndex(x, y);
                return idx === -1 ? true : grid[idx] === MATERIAL.EMPTY;
            }

            // Generate procedural buildings
            generateBuildings() {
                this.trapdoorIndices.clear();
                this.spoutIndices.clear();
                this.spawnerStructures = [];
                const groundLevel = GRID_HEIGHT - 15;
                
                // Ground
                for (let x = 0; x < GRID_WIDTH; x++) {
                    for (let y = groundLevel; y < GRID_HEIGHT; y++) {
                        this.set(x, y, MATERIAL.CONCRETE);
                    }
                }

                // Generate 6-8 buildings
                const numBuildings = 6 + Math.floor(Math.random() * 3);
                const spacing = GRID_WIDTH / numBuildings;

                for (let i = 0; i < numBuildings; i++) {
                    const x = Math.floor(i * spacing + spacing * 0.25);
                    const width = Math.floor(spacing * 0.45 + Math.random() * spacing * 0.25);
                    const height = Math.floor(60 + Math.random() * 120);
                    const floors = Math.floor(height / 20);

                    // Building structure with varied materials
                    for (let bx = x; bx < x + width; bx++) {
                        for (let by = groundLevel - height; by < groundLevel; by++) {
                            // Edge columns are stronger (concrete/metal)
                            if (bx === x || bx === x + width - 1) {
                                this.set(bx, by, MATERIAL.CONCRETE);
                            } else {
                                const material = Math.random() < 0.75 ? MATERIAL.CONCRETE : 
                                               Math.random() < 0.6 ? MATERIAL.METAL : MATERIAL.GLASS;
                                this.set(bx, by, material);
                            }
                        }
                    }

                    // Windows (glass sections)
                    for (let floor = 0; floor < floors; floor++) {
                        const floorY = groundLevel - height + floor * 20 + 4;
                        for (let wx = x + 3; wx < x + width - 3; wx += 6) {
                            for (let wy = floorY; wy < floorY + 10; wy += 1) {
                                if (wx + 2 < x + width - 3 && Math.random() < 0.8) {
                                    this.set(wx, wy, MATERIAL.GLASS);
                                    this.set(wx + 1, wy, MATERIAL.GLASS);
                                }
                            }
                        }
                    }
                }

                // Trapdoors in the ground (top surface) - O opens all, C closes all
                const numTrapdoors = 10 + Math.floor(Math.random() * 6);
                for (let t = 0; t < numTrapdoors; t++) {
                    const tx = 10 + Math.floor(Math.random() * (GRID_WIDTH - 20));
                    const ty = groundLevel;
                    const idx = this.getIndex(tx, ty);
                    if (idx >= 0 && this.get(tx, ty) === MATERIAL.CONCRETE) {
                        this.set(tx, ty, MATERIAL.TRAPDOOR);
                        this.trapdoorIndices.add(idx);
                    }
                }

                this.countParticles();
                this.initialParticles = this.particleCount;
            }

            generateTerrain() {
                this.trapdoorIndices.clear();
                this.spoutIndices.clear();
                this.spawnerStructures = [];
                const groundY = Math.floor(GRID_HEIGHT * 0.72);
                const seed = Math.random() * 10000;
                const n = (x, y, s) => (Math.sin((x + seed) * s * 0.1) * Math.cos((y + seed * 0.7) * s * 0.08) + Math.sin((x + y + seed) * s * 0.05)) * 0.5 + 0.5;

                for (let x = 0; x < GRID_WIDTH; x++) {
                    const heightNoise = n(x, 0, 0.025) * 80;
                    const mountainNoise = n(x * 0.5, 0, 0.03) * 60;
                    let surfY = groundY - Math.floor(heightNoise * 0.6) - Math.floor(mountainNoise * 0.5);
                    const biome = n(x, 0, 0.02);
                    if (biome < 0.35) surfY -= Math.max(0, Math.floor(Math.sin(x * 0.08 + seed) * 5));
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        if (y > surfY) continue;
                        if (n(x, y, 0.08) > 0.52) continue;
                        const depth = surfY - y;
                        let material = MATERIAL.STONE;
                        if (biome < 0.35) {
                            if (depth < 2) material = Math.random() < 0.7 ? MATERIAL.SAND : MATERIAL.DUST;
                            else if (depth < 15) material = Math.random() < 0.85 ? MATERIAL.SAND : MATERIAL.GRAVEL;
                            else material = Math.random() < 0.7 ? MATERIAL.SAND : MATERIAL.STONE;
                        } else if (biome > 0.65) {
                            if (depth < 4) material = Math.random() < 0.6 ? MATERIAL.WOOD : MATERIAL.PLANT;
                            else if (depth < 10) material = Math.random() < 0.7 ? MATERIAL.WOOD : MATERIAL.STONE;
                            else material = Math.random() < 0.5 ? MATERIAL.STONE : MATERIAL.CONCRETE;
                        } else {
                            const peakHeight = groundY - heightNoise * 0.6 - mountainNoise * 0.5;
                            if (depth < 2 && peakHeight < groundY - 40) material = Math.random() < 0.8 ? MATERIAL.SNOW : MATERIAL.ICE;
                            else if (depth < 2) material = Math.random() < 0.5 ? MATERIAL.SAND : MATERIAL.DUST;
                            else if (depth < 8) material = Math.random() < 0.4 ? MATERIAL.CONCRETE : MATERIAL.STONE;
                        }
                        this.set(x, y, material);
                    }
                }


                for (let t = 0; t < 30; t++) {
                    const tx = 15 + Math.floor(Math.random() * (GRID_WIDTH - 50));
                    if (n(tx, 0, 0.02) > 0.6) {
                        let surfY = groundY;
                        for (let y = groundY; y >= 0; y--) {
                            if (this.get(tx, y) !== MATERIAL.EMPTY) { surfY = y; break; }
                        }
                        const h = 4 + Math.floor(Math.random() * 6);
                        for (let dy = 1; dy <= h; dy++) {
                            const y = surfY - dy;
                            if (y >= 0) this.set(tx, y, dy === h ? MATERIAL.PLANT : MATERIAL.WOOD);
                        }
                    }
                }

                for (let i = 0; i < 5; i++) {
                    const px = Math.floor(Math.random() * (GRID_WIDTH - 30)) + 15;
                    const py = groundY - 15 - Math.floor(Math.random() * 60);
                    const size = 3 + Math.floor(Math.random() * 5);
                    const liq = Math.random() < 0.25 ? MATERIAL.LAVA : MATERIAL.LIQUID;
                    for (let dx = -size; dx <= size; dx++) {
                        for (let dy = -size; dy <= size; dy++) {
                            if (dx * dx + dy * dy < size * size && Math.random() < 0.55) {
                                const x = px + dx, y = py + dy;
                                if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT && this.get(x, y) !== MATERIAL.EMPTY)
                                    this.set(x, y, liq);
                            }
                        }
                    }
                }

                for (let s = 0; s < 45; s++) {
                    this.simulate();
                }

                const spawnX = Math.floor(GRID_WIDTH / 2);
                let spawnY = groundY;
                for (let y = groundY; y >= 0; y--) {
                    if (this.get(spawnX, y) !== MATERIAL.EMPTY) { spawnY = y - 2; break; }
                }
                if (spawnY < 0) spawnY = groundY - 5;
                this.set(spawnX, spawnY, MATERIAL.PLAYER_BODY);
                this.set(spawnX, spawnY - 1, MATERIAL.PLAYER_HEAD);
                this.player = { headX: spawnX, headY: spawnY - 1, bodyX: spawnX, bodyY: spawnY, health: 100, maxHealth: 100, dead: false, invincibleUntil: Date.now() + 1500 };
                this.blocksPlaced = 0;
                this.countParticles();
                this.initialParticles = this.particleCount;
            }

            updatePlayer() {
                if (!this.player || this.player.dead) return;
                const p = this.player;
                let moveX = 0;
                if (this.playerKeys.left) moveX = -1;
                if (this.playerKeys.right) moveX = 1;
                if (p.vy === undefined) p.vy = 0;
                p.vy += CONFIG.gravity;
                const canFall = this.isEmpty(p.bodyX, p.bodyY + 1) || this.get(p.bodyX, p.bodyY + 1) === MATERIAL.LIQUID;
                if (canFall && p.vy > 0) {
                    this.set(p.headX, p.headY, this.get(p.bodyX, p.bodyY + 1) === MATERIAL.LIQUID ? MATERIAL.LIQUID : MATERIAL.EMPTY);
                    this.set(p.bodyX, p.bodyY, MATERIAL.EMPTY);
                    p.headY++; p.bodyY++;
                    this.set(p.headX, p.headY, MATERIAL.PLAYER_HEAD);
                    this.set(p.bodyX, p.bodyY, MATERIAL.PLAYER_BODY);
                } else {
                    p.vy = 0;
                    if (moveX !== 0) {
                        const nextX = p.bodyX + moveX;
                        if (this.isEmpty(nextX, p.bodyY) && this.isEmpty(nextX, p.bodyY - 1)) {
                            this.set(p.headX, p.headY, MATERIAL.EMPTY);
                            this.set(p.bodyX, p.bodyY, MATERIAL.EMPTY);
                            p.headX = p.bodyX = nextX;
                            this.set(p.headX, p.headY, MATERIAL.PLAYER_HEAD);
                            this.set(p.bodyX, p.bodyY, MATERIAL.PLAYER_BODY);
                        }
                    }
                    if (this.playerKeys.up) {
                        const canClimb = !this.isEmpty(p.bodyX, p.bodyY - 1) && this.isEmpty(p.bodyX, p.bodyY - 2);
                        if (canClimb) {
                            this.set(p.headX, p.headY, MATERIAL.EMPTY);
                            this.set(p.bodyX, p.bodyY, MATERIAL.EMPTY);
                            p.headY--; p.bodyY--;
                            this.set(p.headX, p.headY, MATERIAL.PLAYER_HEAD);
                            this.set(p.bodyX, p.bodyY, MATERIAL.PLAYER_BODY);
                        }
                    }
                }
                const now = Date.now();
                if (now < p.invincibleUntil) return;
                for (const [hx, hy] of [[p.headX, p.headY], [p.bodyX, p.bodyY]]) {
                    for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                        const m = this.get(hx + dx, hy + dy);
                        if (m === MATERIAL.LAVA || m === MATERIAL.ACID || m === MATERIAL.FIRE || m === MATERIAL.MERCURY) {
                            p.health = Math.max(0, p.health - 2);
                            p.invincibleUntil = now + 400;
                            if (p.health <= 0) {
                                p.dead = true;
                                this.set(p.headX, p.headY, MATERIAL.DUST);
                                this.set(p.bodyX, p.bodyY, MATERIAL.DUST);
                                setTimeout(() => this.respawnPlayer(), 2000);
                            }
                            return;
                        }
                    }
                }
                const below = this.get(p.bodyX, p.bodyY + 1);
                if (below === MATERIAL.LIQUID || below === MATERIAL.ACID) {
                    if (this.frameCount % 30 === 0) {
                        p.health = Math.max(0, p.health - 1);
                        if (p.health <= 0) {
                            p.dead = true;
                            this.set(p.headX, p.headY, MATERIAL.DUST);
                            this.set(p.bodyX, p.bodyY, MATERIAL.DUST);
                            setTimeout(() => this.respawnPlayer(), 2000);
                        }
                    }
                }
            }

            respawnPlayer() {
                if (this.gameMode !== 'survival') return;
                const centerX = Math.floor(GRID_WIDTH / 2);
                let spawnY = Math.floor(GRID_HEIGHT * 0.75);
                for (let y = spawnY; y >= 0; y--) {
                    if (this.get(centerX, y) !== MATERIAL.EMPTY) { spawnY = y - 2; break; }
                }
                this.set(centerX, spawnY, MATERIAL.PLAYER_BODY);
                this.set(centerX, spawnY - 1, MATERIAL.PLAYER_HEAD);
                this.player = { headX: centerX, headY: spawnY - 1, bodyX: centerX, bodyY: spawnY, health: 80, maxHealth: 100, dead: false, invincibleUntil: Date.now() + 2000 };
            }

            addToInventory(material, count) {
                if (this.gameMode !== 'survival') return;
                const gatherable = [MATERIAL.CONCRETE, MATERIAL.STONE, MATERIAL.METAL, MATERIAL.GLASS, MATERIAL.WOOD, MATERIAL.SAND, MATERIAL.DUST, MATERIAL.GRAVEL, MATERIAL.ICE, MATERIAL.LIQUID, MATERIAL.PLANT, MATERIAL.SNOW, MATERIAL.LAVA, MATERIAL.OIL, MATERIAL.STEAM, MATERIAL.SLIME, MATERIAL.GUNPOWDER, MATERIAL.FUSE, MATERIAL.RUBBER, MATERIAL.GLUE_METAL, MATERIAL.TRAPDOOR, MATERIAL.WATER_SPOUT, MATERIAL.LAVA_SPOUT, MATERIAL.ANTIMETAL, MATERIAL.HONEY];
                if (!gatherable.includes(material)) return;
                this.inventory[material] = (this.inventory[material] || 0) + (count || 1);
                this.updateInventoryUI();
            }

            consumeFromInventory(material, count) {
                if (this.gameMode !== 'survival') return true;
                const have = this.inventory[material] || 0;
                const c = count || 1;
                if (have < c) return false;
                this.inventory[material] = have - c;
                if (this.inventory[material] <= 0) delete this.inventory[material];
                this.updateInventoryUI();
                return true;
            }

            updateInventoryUI() {
                if (typeof renderCraftingPanel === 'function' && craftingPanelOpen) renderCraftingPanel();
            }

            // Update humans - they move as connected entities
            updateHumans() {
                for (let i = this.humans.length - 1; i >= 0; i--) {
                    const human = this.humans[i];
                    
                    if (!human.alive) continue;
                    
                    // Check if acid is touching the human
                    const neighbors = [
                        [human.headX, human.headY + 1],
                        [human.headX, human.headY - 1],
                        [human.headX - 1, human.headY],
                        [human.headX + 1, human.headY],
                        [human.bodyX, human.bodyY + 1],
                        [human.bodyX, human.bodyY - 1],
                        [human.bodyX - 1, human.bodyY],
                        [human.bodyX + 1, human.bodyY]
                    ];
                    
                    let touchingAcid = false;
                    let touchingMercury = false;
                    for (const [nx, ny] of neighbors) {
                        const n = this.get(nx, ny);
                        if (n === MATERIAL.ACID) touchingAcid = true;
                        if (n === MATERIAL.MERCURY) touchingMercury = true;
                        if (touchingAcid || touchingMercury) break;
                    }
                    
                    // If acid or mercury (toxic) touches human, convert to static red voxels
                    if (touchingAcid || touchingMercury) {
                        this.set(human.headX, human.headY, MATERIAL.DEAD_HUMAN);
                        this.set(human.bodyX, human.bodyY, MATERIAL.DEAD_HUMAN);
                        human.alive = false;
                        continue;
                    }
                    
                    // Check if human parts still exist
                    const headExists = this.get(human.headX, human.headY) === MATERIAL.HUMAN_HEAD;
                    const bodyExists = this.get(human.bodyX, human.bodyY) === MATERIAL.HUMAN_BODY || 
                                       this.get(human.bodyX, human.bodyY) === MATERIAL.HUMAN_BODY_BUILDER;
                    
                    if (!headExists && !bodyExists) {
                        // Both parts destroyed, remove human
                        this.humans.splice(i, 1);
                        continue;
                    }
                    
                    if (!headExists || !bodyExists) {
                        // One part destroyed, human falls apart
                        human.alive = false;
                        continue;
                    }
                    
                    // Apply gravity
                    human.vy += CONFIG.gravity;
                    
                    // Check if can fall (sink in water and acid too)
                    const below = this.get(human.bodyX, human.bodyY + 1);
                    const canFall = below === MATERIAL.EMPTY || below === MATERIAL.LIQUID || below === MATERIAL.ACID;
                    
                    if (canFall && human.vy > 0) {
                        // Move both voxels down together (falling/sinking)
                        const bodyMat = human.isBuilder ? MATERIAL.HUMAN_BODY_BUILDER : MATERIAL.HUMAN_BODY;
                        // When sinking into liquid/acid, displace it upward to where head was
                        if (below === MATERIAL.LIQUID || below === MATERIAL.ACID) {
                            this.set(human.headX, human.headY, below); // Liquid rises to fill head space
                        } else {
                            this.set(human.headX, human.headY, MATERIAL.EMPTY);
                        }
                        this.set(human.bodyX, human.bodyY, MATERIAL.EMPTY);
                        
                        human.headY += 1;
                        human.bodyY += 1;
                        
                        this.set(human.headX, human.headY, MATERIAL.HUMAN_HEAD);
                        this.set(human.bodyX, human.bodyY, bodyMat);
                    } else {
                        // On ground - Builder AI behavior
                        human.vy = 0;
                        
                        // Try to walk in current direction
                        const nextX = human.bodyX + human.direction;
                        const nextHeadX = human.headX + human.direction;
                        
                        // Check what's ahead
                        const canMoveBody = this.isEmpty(nextX, human.bodyY);
                        const canMoveHead = this.isEmpty(nextHeadX, human.headY);
                        const groundAhead = this.get(nextX, human.bodyY + 1);
                        const hasGround = groundAhead !== MATERIAL.EMPTY;
                        
                        // Check if there's a climbable block (1 level up)
                        // Climbing conditions:
                        // 1. Block at body level ahead (the stair/ledge)
                        // 2. Empty space above that block (where body will go)
                        // 3. Empty space for head above that
                        const hasBlockAtBodyLevel = !this.isEmpty(nextX, human.bodyY);
                        const hasSpaceAbove = this.isEmpty(nextX, human.bodyY - 1);
                        const hasSpaceForHead = this.isEmpty(nextX, human.bodyY - 2);
                        const canClimb = hasBlockAtBodyLevel && hasSpaceAbove && hasSpaceForHead;
                        
                        if (canClimb) {
                            // CLIMB UP one level
                            const bodyMat = human.isBuilder ? MATERIAL.HUMAN_BODY_BUILDER : MATERIAL.HUMAN_BODY;
                            this.set(human.headX, human.headY, MATERIAL.EMPTY);
                            this.set(human.bodyX, human.bodyY, MATERIAL.EMPTY);
                            
                            human.bodyX = nextX;
                            human.bodyY = human.bodyY - 1;
                            human.headX = nextX;
                            human.headY = human.headY - 1;
                            
                            this.set(human.headX, human.headY, MATERIAL.HUMAN_HEAD);
                            this.set(human.bodyX, human.bodyY, bodyMat);
                            
                            human.justBuilt = false;
                        } else if ((!canMoveBody || !canMoveHead) && !canClimb) {
                            // Hit a wall - turn around
                            human.direction *= -1;
                            human.justBuilt = false;
                        } else if (!hasGround && human.isBuilder) {
                            // At an edge - Builder humans BUILD OUTWARD to extend the platform with RANDOMNESS
                            const buildX = nextX;
                            const normalBuildY = human.bodyY + 1; // Ground level
                            
                            // RANDOM BUILDING DECISIONS for organic structures:
                            // 25% chance to build upward (stairs)
                            const buildUpward = Math.random() < 0.25;
                            // 10% chance to build a tower (2-4 blocks high)
                            const buildTower = Math.random() < 0.10;
                            // 5% chance to skip this block entirely (creates gaps)
                            const skipBlock = Math.random() < 0.05;
                            
                            if (skipBlock) {
                                // Occasionally don't build, turn around
                                human.direction *= -1;
                                human.justBuilt = false;
                            } else {
                                // Check if we can build at ground level
                                const materialAtGroundPos = this.get(buildX, normalBuildY);
                                const canBuildGround = materialAtGroundPos === MATERIAL.EMPTY || 
                                    materialAtGroundPos === MATERIAL.ACID || materialAtGroundPos === MATERIAL.MERCURY ||
                                    materialAtGroundPos === MATERIAL.LIQUID ||
                                    materialAtGroundPos === MATERIAL.LAVA ||
                                    materialAtGroundPos === MATERIAL.OIL ||
                                    materialAtGroundPos === MATERIAL.BLOOD ||
                                    materialAtGroundPos === MATERIAL.SLIME ||
                                    materialAtGroundPos === MATERIAL.HONEY;
                                
                                if (canBuildGround) {
                                    // Always build ground block first
                                    this.set(buildX, normalBuildY, MATERIAL.CONCRETE);
                                    const groundIdx = this.getIndex(buildX, normalBuildY);
                                    if (groundIdx !== -1) {
                                        this.humanBuiltBlocks[groundIdx] = true;
                                    }
                                    
                                    // RANDOM UPWARD BUILDING for variety
                                    if (buildTower) {
                                        // Build a small tower (2-4 blocks high)
                                        const towerHeight = Math.floor(Math.random() * 3) + 2; // 2 to 4 blocks
                                        for (let h = 0; h < towerHeight; h++) {
                                            const towerY = normalBuildY - h - 1;
                                            const materialAtTowerPos = this.get(buildX, towerY);
                                            if (materialAtTowerPos === MATERIAL.EMPTY || 
                                                materialAtTowerPos === MATERIAL.ACID || materialAtTowerPos === MATERIAL.MERCURY ||
                                                materialAtTowerPos === MATERIAL.LIQUID ||
                                                materialAtTowerPos === MATERIAL.LAVA ||
                                                materialAtTowerPos === MATERIAL.OIL ||
                                                materialAtTowerPos === MATERIAL.BLOOD ||
                                                materialAtTowerPos === MATERIAL.SLIME ||
                                                materialAtTowerPos === MATERIAL.HONEY) {
                                                
                                                this.set(buildX, towerY, MATERIAL.CONCRETE);
                                                const towerIdx = this.getIndex(buildX, towerY);
                                                if (towerIdx !== -1) {
                                                    this.humanBuiltBlocks[towerIdx] = true;
                                                }
                                            }
                                        }
                                    } else if (buildUpward) {
                                        // Build single stair step (one level up)
                                        const upperBuildY = human.bodyY; // One level up
                                        const materialAtUpperPos = this.get(buildX, upperBuildY);
                                        if (materialAtUpperPos === MATERIAL.EMPTY || 
                                            materialAtUpperPos === MATERIAL.ACID || materialAtUpperPos === MATERIAL.MERCURY ||
                                            materialAtUpperPos === MATERIAL.LIQUID ||
                                            materialAtUpperPos === MATERIAL.LAVA ||
                                            materialAtUpperPos === MATERIAL.OIL ||
                                            materialAtUpperPos === MATERIAL.BLOOD ||
                                            materialAtUpperPos === MATERIAL.SLIME ||
                                            materialAtUpperPos === MATERIAL.HONEY) {
                                            
                                            this.set(buildX, upperBuildY, MATERIAL.CONCRETE);
                                            const upperIdx = this.getIndex(buildX, upperBuildY);
                                            if (upperIdx !== -1) {
                                                this.humanBuiltBlocks[upperIdx] = true;
                                            }
                                        }
                                    }
                                    
                                    human.justBuilt = true;
                                    
                                    // Turn around after building
                                    human.direction *= -1;
                                } else {
                                    // Can't build here, turn around
                                    human.direction *= -1;
                                    human.justBuilt = false;
                                }
                            }
                        } else if (!hasGround && !human.isBuilder) {
                            // Normal human at edge - turn around (no building)
                            human.direction *= -1;
                            human.justBuilt = false;
                        } else {
                            // Normal walking - path is clear
                            human.justBuilt = false;
                            
                            // 3% chance to randomly change direction while walking (adds unpredictability)
                            if (Math.random() < 0.03) {
                                human.direction *= -1;
                            } else {
                                // Move horizontally
                                const bodyMat = human.isBuilder ? MATERIAL.HUMAN_BODY_BUILDER : MATERIAL.HUMAN_BODY;
                                this.set(human.headX, human.headY, MATERIAL.EMPTY);
                                this.set(human.bodyX, human.bodyY, MATERIAL.EMPTY);
                                
                                human.headX = nextHeadX;
                                human.bodyX = nextX;
                                
                                this.set(human.headX, human.headY, MATERIAL.HUMAN_HEAD);
                                this.set(human.bodyX, human.bodyY, bodyMat);
                            }
                        }
                    }
                }
            }

            // Find nearest feces within range (returns [x,y] or null)
            findNearestFeces(flyX, flyY, range) {
                let nearest = null;
                let nearestDist = range + 1;
                for (let gy = Math.max(0, flyY - range); gy <= Math.min(GRID_HEIGHT - 1, flyY + range); gy++) {
                    for (let gx = Math.max(0, flyX - range); gx <= Math.min(GRID_WIDTH - 1, flyX + range); gx++) {
                        if (this.get(gx, gy) === MATERIAL.FEECES) {
                            const dist = Math.sqrt((gx - flyX) ** 2 + (gy - flyY) ** 2);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = [gx, gy];
                            }
                        }
                    }
                }
                return nearest;
            }

            // Update flies - they buzz toward feces when nearby, fall with gravity otherwise
            updateFlies() {
                // Register orphan FLY voxels (placed as material) into flies array - scan every 15 frames
                if (this.frameCount % 15 === 0) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        for (let x = 0; x < GRID_WIDTH; x++) {
                            if (this.get(x, y) === MATERIAL.FLY && !this.flies.some(f => f.x === x && f.y === y)) {
                                this.flies.push({ id: this.nextFlyId++, x, y, alive: true });
                            }
                        }
                    }
                }
                const FEECES_ATTRACT_RANGE = 18;
                for (let i = this.flies.length - 1; i >= 0; i--) {
                    const fly = this.flies[i];
                    if (!fly.alive) continue;

                    // Check if acid or fire touching fly - dies
                    const neighbors = [
                        [fly.x, fly.y + 1], [fly.x, fly.y - 1], [fly.x - 1, fly.y], [fly.x + 1, fly.y]
                    ];
                    for (const [nx, ny] of neighbors) {
                        const m = this.get(nx, ny);
                        if (m === MATERIAL.ACID || m === MATERIAL.FIRE || m === MATERIAL.LAVA || m === MATERIAL.MERCURY) {
                            this.set(fly.x, fly.y, MATERIAL.EMPTY);
                            fly.alive = false;
                            this.flies.splice(i, 1);
                            break;
                        }
                    }
                    if (!fly.alive) continue;

                    if (this.get(fly.x, fly.y) !== MATERIAL.FLY) {
                        this.flies.splice(i, 1);
                        continue;
                    }

                    const feces = this.findNearestFeces(fly.x, fly.y, FEECES_ATTRACT_RANGE);
                    let moveX = 0, moveY = 0;

                    if (feces) {
                        // Move toward feces (flies buzz downward toward it)
                        const dx = feces[0] - fly.x;
                        const dy = feces[1] - fly.y;
                        if (Math.abs(dx) > Math.abs(dy)) {
                            moveX = dx > 0 ? 1 : -1;
                        } else {
                            moveY = dy > 0 ? 1 : -1;
                        }
                    } else {
                        // Gravity-restricted: fall down, occasionally drift sideways
                        moveY = 1;  // Fall with gravity
                        if (Math.random() < 0.3) moveX = Math.random() < 0.5 ? -1 : 1;
                    }

                    const newX = fly.x + moveX;
                    const newY = fly.y + moveY;
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && this.isEmpty(newX, newY)) {
                        this.set(fly.x, fly.y, MATERIAL.EMPTY);
                        fly.x = newX;
                        fly.y = newY;
                        this.set(fly.x, fly.y, MATERIAL.FLY);
                    }
                }
            }

            // Update worms - 1 pink particle that falls/crawls, gravity-restricted
            updateWorms() {
                // Register orphan WORM voxels (placed as material) into worms array - scan every 15 frames
                if (this.frameCount % 15 === 0) {
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        for (let x = 0; x < GRID_WIDTH; x++) {
                            if (this.get(x, y) === MATERIAL.WORM && !this.worms.some(w => w.x === x && w.y === y)) {
                                this.worms.push({ id: this.nextWormId++, x, y, vx: 0, vy: 0 });
                            }
                        }
                    }
                }
                for (let i = this.worms.length - 1; i >= 0; i--) {
                    const worm = this.worms[i];

                    if (this.get(worm.x, worm.y) !== MATERIAL.WORM) {
                        this.worms.splice(i, 1);
                        continue;
                    }

                    // Die if touching acid, fire, or lava
                    const neighbors = [[worm.x, worm.y + 1], [worm.x, worm.y - 1], [worm.x - 1, worm.y], [worm.x + 1, worm.y]];
                    for (const [nx, ny] of neighbors) {
                        const m = this.get(nx, ny);
                        if (m === MATERIAL.ACID || m === MATERIAL.FIRE || m === MATERIAL.LAVA || m === MATERIAL.MERCURY) {
                            this.set(worm.x, worm.y, MATERIAL.EMPTY);
                            this.worms.splice(i, 1);
                            break;
                        }
                    }
                    if (this.worms[i] !== worm) continue;

                    // Ballistic movement when launched by explosion
                    const vx = worm.vx || 0, vy = worm.vy || 0;
                    if (Math.abs(vx) > 0.1 || Math.abs(vy) > 0.1) {
                        worm.vy = (worm.vy || 0) + CONFIG.gravity * 0.8;
                        worm.vx *= 0.97;
                        worm.vy *= 0.97;
                        const moveX = Math.round(worm.vx);
                        const moveY = Math.round(worm.vy);
                        if (moveX !== 0 || moveY !== 0) {
                            const newX = worm.x + moveX, newY = worm.y + moveY;
                            if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && this.isEmpty(newX, newY)) {
                                this.set(worm.x, worm.y, MATERIAL.EMPTY);
                                worm.x = newX;
                                worm.y = newY;
                                this.set(worm.x, worm.y, MATERIAL.WORM);
                            } else {
                                worm.vx *= 0.3;
                                worm.vy *= 0.3;
                            }
                        }
                        continue;
                    }
                    worm.vx = 0;
                    worm.vy = 0;

                    // Crawl movement: fall when nothing below, otherwise wiggle horizontally (no flying)
                    let moveX = 0, moveY = 0;
                    if (this.isEmpty(worm.x, worm.y + 1)) {
                        moveY = 1;  // Fall down
                    } else {
                        moveX = Math.random() < 0.5 ? -1 : 1;  // Crawl left or right
                    }

                    const newX = worm.x + moveX;
                    const newY = worm.y + moveY;
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && this.isEmpty(newX, newY)) {
                        this.set(worm.x, worm.y, MATERIAL.EMPTY);
                        worm.x = newX;
                        worm.y = newY;
                        this.set(worm.x, worm.y, MATERIAL.WORM);
                    }
                }
            }

            // Lead ball shape: rough sphere pattern (big ball, ~13 voxels)
            getLeadBallShape() {
                const voxels = [];
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d <= 2.2) voxels.push({ x: dx, y: dy });
                    }
                }
                return voxels;
            }

            // Launch worms within explosion radius (gunpowder explosion)
            launchWormsNear(ex, ey, radius) {
                for (const worm of this.worms) {
                    const dist = Math.sqrt((worm.x - ex) ** 2 + (worm.y - ey) ** 2);
                    if (dist <= radius && dist > 0) {
                        const dx = worm.x - ex, dy = worm.y - ey;
                        const mag = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = 4 + (radius - dist) * 0.5;
                        worm.vx = worm.vx || 0;
                        worm.vy = worm.vy || 0;
                        worm.vx += (dx / mag) * force;
                        worm.vy += (dy / mag) * force;
                    }
                }
            }

            // Launch pellets within explosion radius - SPREAD pattern (shotgun style)
            launchPelletsNear(ex, ey, radius) {
                for (const ball of this.pelletBalls) {
                    const dist = Math.sqrt((ball.cx - ex) ** 2 + (ball.cy - ey) ** 2);
                    if (dist <= radius) {
                        const dx = ball.cx - ex, dy = ball.cy - ey;
                        const mag = Math.sqrt(dx * dx + dy * dy) || 1;
                        const baseForce = 5 + (radius - dist) * 0.6;
                        const spread = (Math.random() - 0.5) * 0.8;
                        const angle = Math.atan2(dy, dx) + spread;
                        const force = baseForce * (0.8 + Math.random() * 0.4);
                        ball.vx += Math.cos(angle) * force;
                        ball.vy += Math.sin(angle) * force;
                    }
                }
            }

            // Launch lead balls within explosion radius (gunpowder or antimatter)
            launchLeadBallsNear(ex, ey, radius, fromAntimatter = false) {
                for (const ball of this.leadBalls) {
                    let minDist = radius + 1;
                    for (const v of ball.voxels) {
                        const dist = Math.sqrt((ball.cx + v.x - ex) ** 2 + (ball.cy + v.y - ey) ** 2);
                        if (dist < minDist) minDist = dist;
                    }
                    if (minDist <= radius) {
                        const dx = ball.cx - ex, dy = ball.cy - ey;
                        const mag = Math.sqrt(dx * dx + dy * dy) || 1;
                        const force = 6 + (radius - minDist) * 0.8;
                        ball.vx += (dx / mag) * force;
                        ball.vy += (dy / mag) * force;
                        if (fromAntimatter) ball.antimatterLaunched = true;
                    }
                }
            }

            // Check if position is part of any lead ball (for protection from destruction)
            isPartOfLeadBall(px, py) {
                for (const ball of this.leadBalls) {
                    for (const v of ball.voxels) {
                        if (ball.cx + v.x === px && ball.cy + v.y === py) return true;
                    }
                }
                return false;
            }

            // Update lead balls - fixed balls, pixels stuck together, gravity, launched by gunpowder
            updateLeadBalls() {
                const shape = this._leadShape || (this._leadShape = this.getLeadBallShape());
                for (let i = this.leadBalls.length - 1; i >= 0; i--) {
                    const ball = this.leadBalls[i];
                    const voxels = ball.voxels.map(v => ({ x: ball.cx + v.x, y: ball.cy + v.y }));

                    let exists = voxels.every(({ x, y }) => this.get(x, y) === MATERIAL.LEAD);
                    if (!exists) {
                        for (const { x, y } of voxels) {
                            if (this.get(x, y) === MATERIAL.LEAD) this.set(x, y, MATERIAL.GRAVEL);
                        }
                        this.leadBalls.splice(i, 1);
                        continue;
                    }

                    ball.vy += CONFIG.gravity;
                    ball.vx *= 0.98;
                    ball.vy *= 0.98;

                    const moveX = Math.round(ball.vx);
                    const moveY = Math.round(ball.vy);
                    if (moveX === 0 && moveY === 0) continue;

                    const newVoxels = voxels.map(({ x, y }) => ({ x: x + moveX, y: y + moveY }));
                    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const hitsGunpowder = speed > 2 && newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.GUNPOWDER);
                    if (hitsGunpowder) {
                        for (const { x, y } of newVoxels) {
                            if (this.get(x, y) === MATERIAL.GUNPOWDER) this.set(x, y, MATERIAL.FIRE);
                        }
                        ball.vx *= -0.3;
                        ball.vy *= -0.3;
                        continue;
                    }
                    const hitsSlimeOrHoney = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        return m === MATERIAL.SLIME || m === MATERIAL.HONEY;
                    });
                    if (hitsSlimeOrHoney) {
                        ball.vx *= -1.35;
                        ball.vy *= -1.35;
                        continue;
                    }
                    const hitsGlueMetalOrTrapdoor = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        return m === MATERIAL.GLUE_METAL || m === MATERIAL.TRAPDOOR;
                    });
                    if (hitsGlueMetalOrTrapdoor) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsLeadBrick = newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.LEAD_BRICK);
                    if (hitsLeadBrick) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsRubber = newVoxels.some(({ x, y }) => this.get(x, y) === MATERIAL.RUBBER);
                    if (hitsRubber) {
                        if (speed > 2) this.screenShake = Math.min(12, this.screenShake + speed * 0.8);
                        ball.vx *= -1.5;
                        ball.vy *= -1.5;
                        continue;
                    }
                    const hitsAntimatter = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        return m === MATERIAL.ANTIMATTER || m === MATERIAL.ANTIMATTER_BLAST;
                    }) || voxels.some(({ x, y }) => {
                        const neighbors = [[x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]];
                        return neighbors.some(([nx, ny]) => {
                            const m = this.get(nx, ny);
                            return m === MATERIAL.ANTIMATTER || m === MATERIAL.ANTIMATTER_BLAST;
                        });
                    });
                    if (hitsAntimatter) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsHuman = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        return m === MATERIAL.HUMAN_HEAD || m === MATERIAL.HUMAN_BODY || m === MATERIAL.HUMAN_BODY_BUILDER;
                    });

                    // Block at any solid/liquid - lead balls always obey gravity and collision
                    const hitsSolid = newVoxels.some(({ x, y }) => {
                        const m = this.get(x, y);
                        if (m === MATERIAL.EMPTY) return false;
                        if (m === MATERIAL.LEAD && voxels.some(v => v.x === x && v.y === y)) return false; // own voxel overlap
                        return true;
                    });
                    if (hitsSolid) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }

                    if (hitsHuman && speed > 2) {
                        for (const h of this.humans) {
                            if (!h.alive) continue;
                            const touched = newVoxels.some(({ x, y }) =>
                                (x === h.headX && y === h.headY) || (x === h.bodyX && y === h.bodyY));
                            if (touched) {
                                this.set(h.headX, h.headY, MATERIAL.DEAD_HUMAN);
                                this.set(h.bodyX, h.bodyY, MATERIAL.DEAD_HUMAN);
                                h.alive = false;
                            }
                        }
                        ball.vx *= 0.5;
                        ball.vy *= 0.5;
                    }

                    for (const { x, y } of voxels) this.set(x, y, MATERIAL.EMPTY);
                    for (const { x, y } of newVoxels) {
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT)
                            this.set(x, y, MATERIAL.LEAD);
                    }
                    ball.cx += moveX;
                    ball.cy += moveY;
                }
            }

            // Update pellets - single-voxel projectiles, lighter than lead, bounce off rubber
            updatePellets() {
                for (let i = this.pelletBalls.length - 1; i >= 0; i--) {
                    const ball = this.pelletBalls[i];
                    const px = ball.cx, py = ball.cy;
                    if (this.get(px, py) !== MATERIAL.PELLET) {
                        this.pelletBalls.splice(i, 1);
                        continue;
                    }
                    ball.vy += CONFIG.gravity * 1.2;
                    ball.vx *= 0.98;
                    ball.vy *= 0.98;
                    const moveX = Math.round(ball.vx);
                    const moveY = Math.round(ball.vy);
                    if (moveX === 0 && moveY === 0) continue;
                    const newX = px + moveX, newY = py + moveY;
                    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const targetMat = this.get(newX, newY);
                    const hitsGunpowder = speed > 2 && targetMat === MATERIAL.GUNPOWDER;
                    if (hitsGunpowder) {
                        this.set(newX, newY, MATERIAL.FIRE);
                        ball.vx *= -0.3;
                        ball.vy *= -0.3;
                        continue;
                    }
                    const hitsSlimeOrHoney = targetMat === MATERIAL.SLIME || targetMat === MATERIAL.HONEY;
                    if (hitsSlimeOrHoney) {
                        if (speed > 3) this.screenShake = Math.min(12, this.screenShake + speed * 0.8);
                        ball.vx *= -1.2;
                        ball.vy *= -1.2;
                        continue;
                    }
                    const hitsGlueMetalOrTrapdoor = targetMat === MATERIAL.GLUE_METAL || targetMat === MATERIAL.TRAPDOOR;
                    if (hitsGlueMetalOrTrapdoor) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsLeadBrick = targetMat === MATERIAL.LEAD_BRICK;
                    if (hitsLeadBrick) {
                        ball.vx = 0;
                        ball.vy = 0;
                        continue;
                    }
                    const hitsRubber = targetMat === MATERIAL.RUBBER;
                    if (hitsRubber) {
                        if (speed > 2) this.screenShake = Math.min(10, this.screenShake + speed * 0.6);
                        ball.vx *= -1.6;
                        ball.vy *= -1.6;
                        continue;
                    }
                    const hitsHuman = targetMat === MATERIAL.HUMAN_HEAD || targetMat === MATERIAL.HUMAN_BODY || targetMat === MATERIAL.HUMAN_BODY_BUILDER;
                    if (hitsHuman && speed > 2) {
                        for (const h of this.humans) {
                            if (!h.alive) continue;
                            if ((newX === h.headX && newY === h.headY) || (newX === h.bodyX && newY === h.bodyY)) {
                                this.set(h.headX, h.headY, MATERIAL.DEAD_HUMAN);
                                this.set(h.bodyX, h.bodyY, MATERIAL.DEAD_HUMAN);
                                h.alive = false;
                            }
                        }
                        ball.vx *= 0.5;
                        ball.vy *= 0.5;
                    }
                    if (targetMat !== MATERIAL.EMPTY && !hitsHuman) {
                        this.set(px, py, MATERIAL.DUST);
                        this.pelletBalls.splice(i, 1);
                        continue;
                    }
                    this.set(px, py, MATERIAL.EMPTY);
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT)
                        this.set(newX, newY, MATERIAL.PELLET);
                    ball.cx = newX;
                    ball.cy = newY;
                }
            }

            // Physics simulation (cellular automata)
            simulate() {
                // Update humans first (they move as units)
                this.updateHumans();
                this.updateFlies();
                this.updateWorms();
                this.updateLeadBalls();
                this.updatePellets();
                this.updateSpawners();
                this.updateSpouts();
                
                const newGrid = [...this.grid];
                const newVelX = [...this.velocityX];
                const newVelY = [...this.velocityY];
                const now = Date.now();

                // Clean up old debris particles (disappear after 2 seconds)
                for (let i = 0; i < this.grid.length; i++) {
                    if (this.grid[i] === MATERIAL.DUST && this.particleAge[i] > 0) {
                        if (now - this.particleAge[i] > 2000) {
                            newGrid[i] = MATERIAL.EMPTY;
                            this.particleAge[i] = 0;
                        }
                    }
                }

                // Process all cells in random order so voxels fall together (not by row)
                const totalCells = GRID_WIDTH * GRID_HEIGHT;
                if (!this._simOrder || this._simOrder.length !== totalCells) {
                    this._simOrder = new Int32Array(totalCells);
                    for (let i = 0; i < totalCells; i++) this._simOrder[i] = i;
                }
                for (let i = totalCells - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    const t = this._simOrder[i];
                    this._simOrder[i] = this._simOrder[j];
                    this._simOrder[j] = t;
                }
                const emptyIn = (g, ax, ay) => this.isEmptyIn(g, ax, ay);
                for (let si = 0; si < totalCells; si++) {
                    const idx = this._simOrder[si];
                    const y = Math.floor(idx / GRID_WIDTH);
                    const x = idx % GRID_WIDTH;
                    if (y >= GRID_HEIGHT - 1) continue;
                        const material = this.grid[idx];

                        if (material === MATERIAL.EMPTY) continue;
                        
                        // Skip human materials - they're handled separately as connected entities
                        if (material === MATERIAL.HUMAN_HEAD || material === MATERIAL.HUMAN_BODY || material === MATERIAL.HUMAN_BODY_BUILDER) continue;
                        
                        // Skip flies - they're handled separately as life-form entities
                        if (material === MATERIAL.FLY) continue;
                        
                        // Skip lead - handled as connected ball entities
                        if (material === MATERIAL.LEAD) continue;
                        
                        // Skip pellets - handled as projectile entities
                        if (material === MATERIAL.PELLET) continue;
                        
                        // Skip worms - handled as life-form entities
                        if (material === MATERIAL.WORM) continue;
                        
                        // Skip dead humans - they don't move (static red voxels)
                        if (material === MATERIAL.DEAD_HUMAN) continue;
                        
                        // Skip fuse - sticks in air, doesn't fall
                        if (material === MATERIAL.FUSE) continue;

                        const props = MATERIAL_PROPS[material];
                        const vx = this.velocityX[idx];
                        const vy = this.velocityY[idx];

                        // Apply gravity
                        let newVY = vy + CONFIG.gravity;
                        let newVX = vx * 0.95; // Friction

                        let moved = false;

                        // LAVA: Burns and melts weaker materials
                        if (material === MATERIAL.LAVA) {
                            // Lava destroys weaker materials (not metal or concrete)
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            // WATER + LAVA = Stone (molten rock cools when quenched)
                            let lavaQuenched = false;
                            for (const [nx, ny] of neighbors) {
                                if (this.get(nx, ny) === MATERIAL.LIQUID) {
                                    newGrid[idx] = MATERIAL.STONE;
                                    newGrid[this.getIndex(nx, ny)] = MATERIAL.STEAM;
                                    lavaQuenched = true;
                                    break;
                                }
                            }
                            if (!lavaQuenched) {
                                for (const [nx, ny] of neighbors) {
                                    const neighborMat = this.get(nx, ny);
                                    // SAND + LAVA = Glass (silica melts and forms glass)
                                    if (neighborMat === MATERIAL.SAND && Math.random() < 0.25) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.GLASS;
                                    }
                                    // METAL + LAVA: Metal melts (high heat melts metals)
                                    else if (neighborMat === MATERIAL.METAL && Math.random() < 0.08) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LAVA;
                                    }
                                    // Burns dust, glass, humans and converts them to lava or dust
                                    else if ((neighborMat === MATERIAL.DUST || neighborMat === MATERIAL.GLASS || neighborMat === MATERIAL.WOOD) && Math.random() < 0.2) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LAVA;
                                    } else if (neighborMat === MATERIAL.FUSE && Math.random() < 0.95) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.GUNPOWDER) {
                                        // LAVA + GUNPOWDER = GIANT EXPLOSION
                                        const explosionRadius = 8;
                                        for (let ex = nx - explosionRadius; ex <= nx + explosionRadius; ex++) {
                                            for (let ey = ny - explosionRadius; ey <= ny + explosionRadius; ey++) {
                                                const eIdx = this.getIndex(ex, ey);
                                                if (eIdx === -1) continue;
                                                const dist = Math.sqrt((ex - nx) ** 2 + (ey - ny) ** 2);
                                                if (dist <= explosionRadius && this.get(ex, ey) === MATERIAL.GUNPOWDER) {
                                                    newGrid[eIdx] = MATERIAL.FIRE;
                                                }
                                                if (dist <= explosionRadius * 0.6 && (this.get(ex, ey) === MATERIAL.DUST || this.get(ex, ey) === MATERIAL.WOOD || this.get(ex, ey) === MATERIAL.PLANT)) {
                                                    if (Math.random() < 0.7) newGrid[eIdx] = MATERIAL.FIRE;
                                                }
                                            }
                                        }
                                        const nIdxLava = this.getIndex(nx, ny);
                                        if (nIdxLava !== -1) newGrid[nIdxLava] = MATERIAL.FIRE;
                                        this.launchLeadBallsNear(nx, ny, explosionRadius);
                                        this.launchPelletsNear(nx, ny, explosionRadius);
                                        this.launchWormsNear(nx, ny, explosionRadius);
                                        break; // One explosion per lava voxel
                                    } else if (neighborMat === MATERIAL.ANTIMATTER) {
                                        // LAVA + ANTIMATTER = Purple/blue blast (4 voxel core destroys everything)
                                        const blastEx = nx, blastEy = ny;
                                        for (let bx = blastEx - 12; bx <= blastEx + 12; bx++) {
                                            for (let by = blastEy - 12; by <= blastEy + 12; by++) {
                                                const dist = Math.sqrt((bx - blastEx) ** 2 + (by - blastEy) ** 2);
                                                const bIdx = this.getIndex(bx, by);
                                                if (bIdx === -1) continue;
                                                const targetMat = this.get(bx, by);
                                                if (targetMat === MATERIAL.ANTIMETAL || targetMat === MATERIAL.LEAD) continue;
                                                if (dist <= 4) newGrid[bIdx] = MATERIAL.EMPTY;
                                                else if (dist <= 12 && targetMat !== MATERIAL.EMPTY) newGrid[bIdx] = MATERIAL.ANTIMATTER_BLAST;
                                            }
                                        }
                                        this.launchLeadBallsNear(blastEx, blastEy, 12, true);
                                        this.launchPelletsNear(blastEx, blastEy, 12);
                                        this.launchWormsNear(blastEx, blastEy, 12);
                                        for (const h of this.humans) {
                                            const hDist = Math.sqrt((h.headX - blastEx) ** 2 + (h.headY - blastEy) ** 2);
                                            if (hDist <= 12) {
                                                newGrid[this.getIndex(h.headX, h.headY)] = MATERIAL.DEAD_HUMAN;
                                                newGrid[this.getIndex(h.bodyX, h.bodyY)] = MATERIAL.DEAD_HUMAN;
                                                h.alive = false;
                                            }
                                        }
                                        break;
                                    } else if ((neighborMat === MATERIAL.HUMAN_HEAD || neighborMat === MATERIAL.HUMAN_BODY || neighborMat === MATERIAL.HUMAN_BODY_BUILDER) && Math.random() < 0.15) {
                                        // Humans burn to dust
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.DUST;
                                    } else if (neighborMat === MATERIAL.GRAVEL && Math.random() < 0.15) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.STONE;
                                    } else if (neighborMat === MATERIAL.GLASS && Math.random() < 0.3) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LAVA;
                                    } else if (neighborMat === MATERIAL.GLUE_METAL && Math.random() < 0.12) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LAVA;
                                    } else if (neighborMat === MATERIAL.RUBBER && Math.random() < 0.25) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.FIRE;
                                    }
                                }
                            }
                        }

                        // ACID: Destroys everything it touches - EXTREMELY satisfying!
                        if (material === MATERIAL.ACID) {
                            // Check all 8 neighbors and destroy them aggressively
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y],
                                [x - 1, y + 1], [x + 1, y + 1], [x - 1, y - 1], [x + 1, y - 1]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if (neighborMat !== MATERIAL.EMPTY && neighborMat !== MATERIAL.ACID && neighborMat !== MATERIAL.DEAD_HUMAN && neighborMat !== MATERIAL.SLIME && neighborMat !== MATERIAL.HONEY && neighborMat !== MATERIAL.MERCURY && neighborMat !== MATERIAL.LEAD) {
                                    let corrodeChance = 0.7;
                                    if (neighborMat === MATERIAL.STONE) corrodeChance = 0.06;
                                    else if (neighborMat === MATERIAL.METAL) corrodeChance = 0.12;
                                    else if (neighborMat === MATERIAL.CONCRETE || neighborMat === MATERIAL.LEAD_BRICK) corrodeChance = 0.45;
                                    if ((neighborMat === MATERIAL.HUMAN_HEAD || neighborMat === MATERIAL.HUMAN_BODY || neighborMat === MATERIAL.HUMAN_BODY_BUILDER) && Math.random() < 0.7) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.DEAD_HUMAN;
                                    }
                                    else if (neighborMat === MATERIAL.PLANT && Math.random() < 0.8) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.EMPTY;
                                    } else if (neighborMat === MATERIAL.ICE && Math.random() < 0.6) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.LIQUID;
                                    } else if (neighborMat === MATERIAL.SAND && Math.random() < 0.5) {
                                        newGrid[this.getIndex(nx, ny)] = MATERIAL.EMPTY;
                                    }
                                    else if (Math.random() < corrodeChance) {
                                        newGrid[this.getIndex(nx, ny)] = neighborMat === MATERIAL.METAL ? MATERIAL.DUST : MATERIAL.EMPTY;
                                    }
                                }
                            }
                            
                            // Sometimes acid also spreads aggressively to dissolve more
                            if (Math.random() < 0.2) {
                                const spreadDir = Math.random() < 0.5 ? -1 : 1;
                                const spreadX = x + spreadDir;
                                const spreadY = y;
                                const spreadMat = this.get(spreadX, spreadY);
                                if (spreadMat !== MATERIAL.EMPTY && spreadMat !== MATERIAL.ACID && spreadMat !== MATERIAL.SLIME && spreadMat !== MATERIAL.HONEY && spreadMat !== MATERIAL.LEAD) {
                                    newGrid[this.getIndex(spreadX, spreadY)] = MATERIAL.ACID;
                                }
                            }
                        }

                        // FIRE: Burns materials and rises like smoke
                        if (material === MATERIAL.FIRE) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            // WATER extinguishes FIRE - produces steam
                            let fireExtinguished = false;
                            for (const [nx, ny] of neighbors) {
                                if (this.get(nx, ny) === MATERIAL.LIQUID) {
                                    newGrid[idx] = MATERIAL.STEAM;
                                    fireExtinguished = true;
                                    break;
                                }
                            }
                            if (!fireExtinguished) {
                                for (const [nx, ny] of neighbors) {
                                    const neighborMat = this.get(nx, ny);
                                    const nIdx = this.getIndex(nx, ny);
                                    
                                    // GUNPOWDER + FIRE = GIANT EXPLOSION
                                    if (neighborMat === MATERIAL.GUNPOWDER) {
                                        const explosionRadius = 8;
                                        for (let ex = nx - explosionRadius; ex <= nx + explosionRadius; ex++) {
                                            for (let ey = ny - explosionRadius; ey <= ny + explosionRadius; ey++) {
                                                const eIdx = this.getIndex(ex, ey);
                                                if (eIdx === -1) continue;
                                                const dist = Math.sqrt((ex - nx) ** 2 + (ey - ny) ** 2);
                                                if (dist <= explosionRadius && this.get(ex, ey) === MATERIAL.GUNPOWDER) {
                                                    newGrid[eIdx] = MATERIAL.FIRE;
                                                }
                                                if (dist <= explosionRadius * 0.6 && (this.get(ex, ey) === MATERIAL.DUST || this.get(ex, ey) === MATERIAL.WOOD || this.get(ex, ey) === MATERIAL.PLANT)) {
                                                    if (Math.random() < 0.7) newGrid[eIdx] = MATERIAL.FIRE;
                                                }
                                            }
                                        }
                                        if (nIdx !== -1) newGrid[nIdx] = MATERIAL.FIRE;
                                        this.launchLeadBallsNear(nx, ny, explosionRadius);
                                        this.launchPelletsNear(nx, ny, explosionRadius);
                                        this.launchWormsNear(nx, ny, explosionRadius);
                                        break; // One explosion per fire voxel
                                    } else if (neighborMat === MATERIAL.ANTIMATTER) {
                                        // FIRE + ANTIMATTER = Purple/blue blast (4 voxel core destroys everything)
                                        const blastEx = nx, blastEy = ny;
                                        for (let bx = blastEx - 12; bx <= blastEx + 12; bx++) {
                                            for (let by = blastEy - 12; by <= blastEy + 12; by++) {
                                                const dist = Math.sqrt((bx - blastEx) ** 2 + (by - blastEy) ** 2);
                                                const bIdx = this.getIndex(bx, by);
                                                if (bIdx === -1) continue;
                                                const targetMat = this.get(bx, by);
                                                if (targetMat === MATERIAL.ANTIMETAL || targetMat === MATERIAL.LEAD) continue;
                                                if (dist <= 4) newGrid[bIdx] = MATERIAL.EMPTY;
                                                else if (dist <= 12 && targetMat !== MATERIAL.EMPTY) newGrid[bIdx] = MATERIAL.ANTIMATTER_BLAST;
                                            }
                                        }
                                        this.launchLeadBallsNear(blastEx, blastEy, 12, true);
                                        this.launchPelletsNear(blastEx, blastEy, 12);
                                        this.launchWormsNear(blastEx, blastEy, 12);
                                        for (const h of this.humans) {
                                            const hDist = Math.sqrt((h.headX - blastEx) ** 2 + (h.headY - blastEy) ** 2);
                                            if (hDist <= 12) {
                                                newGrid[this.getIndex(h.headX, h.headY)] = MATERIAL.DEAD_HUMAN;
                                                newGrid[this.getIndex(h.bodyX, h.bodyY)] = MATERIAL.DEAD_HUMAN;
                                                h.alive = false;
                                            }
                                        }
                                        break;
                                    } else if (neighborMat === MATERIAL.FUSE) {
                                        if (Math.random() < 0.92) newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.OIL && Math.random() < 0.3) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.BLOOD && Math.random() < 0.2) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.FEECES && Math.random() < 0.08) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.PLANT && Math.random() < 0.2) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.WOOD) {
                                        const woodWet = this.get(nx, ny - 1) === MATERIAL.LIQUID || this.get(nx, ny + 1) === MATERIAL.LIQUID ||
                                            this.get(nx - 1, ny) === MATERIAL.LIQUID || this.get(nx + 1, ny) === MATERIAL.LIQUID;
                                        if (Math.random() < (woodWet ? 0.06 : 0.25)) newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.ICE && Math.random() < 0.1) {
                                        newGrid[nIdx] = MATERIAL.LIQUID;
                                    } else if (neighborMat === MATERIAL.DUST && Math.random() < 0.22) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.HONEY && Math.random() < 0.2) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    } else if (neighborMat === MATERIAL.RUBBER && Math.random() < 0.18) {
                                        newGrid[nIdx] = MATERIAL.FIRE;
                                    }
                                }
                                
                                if (Math.random() < 0.008) {
                                    const emberDirs = [[x, y - 1], [x - 1, y - 1], [x + 1, y - 1], [x - 1, y], [x + 1, y]];
                                    for (const [ex, ey] of emberDirs) {
                                        if (emptyIn(newGrid, ex, ey) && Math.random() < 0.5) {
                                            newGrid[this.getIndex(ex, ey)] = MATERIAL.EMBER;
                                            break;
                                        }
                                    }
                                }
                                
                                // Fire dies out randomly
                                if (Math.random() < 0.05) {
                                    newGrid[idx] = MATERIAL.STEAM;
                                }
                            }
                        }

                        // ANTIMATTER_BLAST: Purple/blue blast - ignites antimatter (chain reaction), burns things
                        if (material === MATERIAL.ANTIMATTER_BLAST) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                const nIdx = this.getIndex(nx, ny);
                                if (neighborMat === MATERIAL.ANTIMATTER) {
                                    // Chain reaction: antimatter ignites!
                                    const blastEx = nx, blastEy = ny;
                                    for (let bx = blastEx - 12; bx <= blastEx + 12; bx++) {
                                        for (let by = blastEy - 12; by <= blastEy + 12; by++) {
                                            const dist = Math.sqrt((bx - blastEx) ** 2 + (by - blastEy) ** 2);
                                            const bIdx = this.getIndex(bx, by);
                                            if (bIdx === -1) continue;
                                            const targetMat = this.get(bx, by);
                                            if (targetMat === MATERIAL.ANTIMETAL) continue; // Antimetal blocks blast
                                            if (dist <= 4) newGrid[bIdx] = MATERIAL.EMPTY;
                                            else if (dist <= 12 && targetMat !== MATERIAL.EMPTY) newGrid[bIdx] = MATERIAL.ANTIMATTER_BLAST;
                                        }
                                    }
                                    this.launchLeadBallsNear(blastEx, blastEy, 12, true);
                                    this.launchPelletsNear(blastEx, blastEy, 12);
                                    this.launchWormsNear(blastEx, blastEy, 12);
                                    for (const h of this.humans) {
                                        const hDist = Math.sqrt((h.headX - blastEx) ** 2 + (h.headY - blastEy) ** 2);
                                        if (hDist <= 12) {
                                            newGrid[this.getIndex(h.headX, h.headY)] = MATERIAL.DEAD_HUMAN;
                                            newGrid[this.getIndex(h.bodyX, h.bodyY)] = MATERIAL.DEAD_HUMAN;
                                            h.alive = false;
                                        }
                                    }
                                    break;
                                } else if (nIdx !== -1 && (neighborMat === MATERIAL.WOOD || neighborMat === MATERIAL.PLANT || neighborMat === MATERIAL.OIL)) {
                                    if (Math.random() < 0.15) newGrid[nIdx] = MATERIAL.ANTIMATTER_BLAST;
                                }
                            }
                            if (Math.random() < 0.12) newGrid[idx] = MATERIAL.EMPTY; // Blast fades quickly to prevent persistent buildup
                        }

                        // EMBER: Hot glowing particles - ignite flammables, extinguish in water
                        if (material === MATERIAL.EMBER) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            let emberExtinguished = false;
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                const nIdx = this.getIndex(nx, ny);
                                if (neighborMat === MATERIAL.LIQUID || neighborMat === MATERIAL.MILK) {
                                    newGrid[idx] = MATERIAL.STEAM;
                                    emberExtinguished = true;
                                    break;
                                }
                                if (neighborMat === MATERIAL.OIL && Math.random() < 0.35) {
                                    newGrid[nIdx] = MATERIAL.FIRE;
                                    break;
                                }
                                if (neighborMat === MATERIAL.WOOD && Math.random() < 0.2) {
                                    newGrid[nIdx] = MATERIAL.FIRE;
                                    break;
                                }
                                if (neighborMat === MATERIAL.GUNPOWDER) {
                                    const explosionRadius = 6;
                                    for (let ex = nx - explosionRadius; ex <= nx + explosionRadius; ex++) {
                                        for (let ey = ny - explosionRadius; ey <= ny + explosionRadius; ey++) {
                                            const eIdx = this.getIndex(ex, ey);
                                            if (eIdx === -1) continue;
                                            const dist = Math.sqrt((ex - nx) ** 2 + (ey - ny) ** 2);
                                            if (dist <= explosionRadius && this.get(ex, ey) === MATERIAL.GUNPOWDER) {
                                                newGrid[eIdx] = MATERIAL.FIRE;
                                            }
                                        }
                                    }
                                    if (nIdx !== -1) newGrid[nIdx] = MATERIAL.FIRE;
                                    this.launchLeadBallsNear(nx, ny, explosionRadius);
                                    this.launchPelletsNear(nx, ny, explosionRadius);
                                    this.launchWormsNear(nx, ny, explosionRadius);
                                    break;
                                }
                            }
                        }

                        if (material === MATERIAL.PLANT) {
                            const hasWater = this.get(x, y - 1) === MATERIAL.LIQUID || this.get(x, y + 1) === MATERIAL.LIQUID ||
                                this.get(x - 1, y) === MATERIAL.LIQUID || this.get(x + 1, y) === MATERIAL.LIQUID;
                            const growthChance = hasWater ? 0.014 : 0.008;
                            if (Math.random() < growthChance) {
                                const hasGroundBelow = !emptyIn(newGrid, x, y + 1);
                                const growthChoices = [];
                                
                                if (Math.random() < 0.5 && emptyIn(newGrid, x, y - 1)) {
                                    growthChoices.push([x, y - 1]);
                                }
                                if (Math.random() < 0.25) {
                                    if (emptyIn(newGrid, x - 1, y)) growthChoices.push([x - 1, y]);
                                    if (emptyIn(newGrid, x + 1, y)) growthChoices.push([x + 1, y]);
                                }
                                if (Math.random() < 0.15) {
                                    if (emptyIn(newGrid, x - 1, y - 1)) growthChoices.push([x - 1, y - 1]);
                                    if (emptyIn(newGrid, x + 1, y - 1)) growthChoices.push([x + 1, y - 1]);
                                }
                                if (Math.random() < 0.10 && emptyIn(newGrid, x, y + 1)) {
                                    growthChoices.push([x, y + 1]);
                                }
                                
                                // Grow in a random chosen direction
                                if (growthChoices.length > 0) {
                                    const [gx, gy] = growthChoices[Math.floor(Math.random() * growthChoices.length)];
                                    const growIdx = this.getIndex(gx, gy);
                                    
                                    // Check for nearby plants to create dense clusters
                                    const nearbyPlants = [
                                        [gx, gy - 1], [gx, gy + 1], [gx - 1, gy], [gx + 1, gy]
                                    ].filter(([nx, ny]) => this.get(nx, ny) === MATERIAL.PLANT).length;
                                    
                                    // More likely to grow if near other plants (clustering effect)
                                    if (nearbyPlants > 0 || Math.random() < 0.6) {
                                        newGrid[growIdx] = MATERIAL.PLANT;
                                        
                                        // Assign plant type: 55% green, 35% brown stem, 10% flower
                                        const r = Math.random();
                                        if (r < 0.10) {
                                            // Flower - bright colors: yellow, red, pink, orange, magenta
                                            this.plantType[growIdx] = 2 + Math.floor(Math.random() * 5);
                                        } else if (r < 0.45) {
                                            this.plantType[growIdx] = 1; // Brown stem
                                        } else {
                                            this.plantType[growIdx] = 0; // Green leaf
                                        }
                                    }
                                }
                                
                                // Small chance to stop growing (die back) if too isolated
                                if (Math.random() < 0.001) {
                                    const nearbyPlants = [
                                        [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y]
                                    ].filter(([nx, ny]) => this.get(nx, ny) === MATERIAL.PLANT).length;
                                    
                                    if (nearbyPlants === 0) {
                                        newGrid[idx] = MATERIAL.EMPTY; // Isolated plants die
                                        this.plantType[idx] = 0; // Clear plant type
                                    }
                                }
                            }
                        }

                        // ICE: Melts near hot materials
                        if (material === MATERIAL.ICE) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.LAVA || neighborMat === MATERIAL.FIRE) && Math.random() < 0.3) {
                                    newGrid[idx] = MATERIAL.LIQUID; // Melts to water
                                    break;
                                }
                            }
                        }

                        // SNOW: Melts near hot materials, accumulates
                        if (material === MATERIAL.SNOW) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.LAVA || neighborMat === MATERIAL.FIRE) && Math.random() < 0.4) {
                                    newGrid[idx] = MATERIAL.LIQUID; // Melts to water
                                    break;
                                }
                            }
                        }

                        // GUNPOWDER + WATER: Becomes inert (wet gunpowder doesn't explode)
                        if (material === MATERIAL.GUNPOWDER) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            for (const [nx, ny] of neighbors) {
                                if (this.get(nx, ny) === MATERIAL.LIQUID) {
                                    newGrid[idx] = MATERIAL.DUST;
                                    break;
                                }
                            }
                        }

                        // WATER: Freezes when surrounded by ice/snow (cold transfers)
                        if (material === MATERIAL.LIQUID) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            let coldCount = 0;
                            for (const [nx, ny] of neighbors) {
                                const n = this.get(nx, ny);
                                if (n === MATERIAL.ICE || n === MATERIAL.SNOW) coldCount++;
                            }
                            if (coldCount >= 2 && Math.random() < 0.08) {
                                newGrid[idx] = MATERIAL.ICE;
                            }
                        }

                        // MILK: Curdles/evaporates near heat - becomes steam
                        if (material === MATERIAL.MILK) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.FIRE || neighborMat === MATERIAL.LAVA || neighborMat === MATERIAL.EMBER) && Math.random() < 0.4) {
                                    newGrid[idx] = MATERIAL.STEAM;
                                    break;
                                }
                            }
                        }

                        // OIL: Ignites near fire
                        if (material === MATERIAL.OIL) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            
                            for (const [nx, ny] of neighbors) {
                                const neighborMat = this.get(nx, ny);
                                if ((neighborMat === MATERIAL.FIRE || neighborMat === MATERIAL.LAVA) && Math.random() < 0.5) {
                                    newGrid[idx] = MATERIAL.FIRE; // Oil catches fire!
                                    break;
                                }
                            }
                        }

                        // STEAM: Condenses to water when near cold (ice, snow) or at top of screen
                        if (material === MATERIAL.STEAM) {
                            const neighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]
                            ];
                            const atTop = y < GRID_HEIGHT * 0.1;
                            let nearCold = false;
                            for (const [nx, ny] of neighbors) {
                                const n = this.get(nx, ny);
                                if (n === MATERIAL.ICE || n === MATERIAL.SNOW) {
                                    nearCold = true;
                                    break;
                                }
                            }
                            if ((nearCold || atTop) && Math.random() < 0.15) {
                                newGrid[idx] = MATERIAL.LIQUID;
                            }
                        }

                        // STEAM: Rises (handled in flow section with special logic)
                        // BLOOD: Acts like water but thicker
                        // SLIME: Very slow viscous liquid (handled in flow)
                        // SAND: Fast-falling particles (handled in flow)

                        // BACTERIA: Reproduces near nutrients (water, blood, milk, feces), dies from heat/acid/mercury
                        if (material === MATERIAL.BACTERIA) {
                            // Die from acid, fire, lava, mercury (toxic)
                            const deadlyNeighbors = [
                                [x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y],
                                [x - 1, y + 1], [x + 1, y + 1], [x - 1, y - 1], [x + 1, y - 1]
                            ];
                            let willDie = false;
                            for (const [nx, ny] of deadlyNeighbors) {
                                const n = this.get(nx, ny);
                                if (n === MATERIAL.ACID || n === MATERIAL.FIRE || n === MATERIAL.LAVA || n === MATERIAL.MERCURY) {
                                    willDie = true;
                                    break;
                                }
                            }
                            if (willDie) {
                                newGrid[idx] = MATERIAL.EMPTY;
                            } else {
                                // Reproduce when near nutrients (water, blood, milk, feces)
                                const nutrientMats = [MATERIAL.LIQUID, MATERIAL.BLOOD, MATERIAL.MILK, MATERIAL.FEECES];
                                let hasNutrient = false;
                                for (const [nx, ny] of [[x, y + 1], [x, y - 1], [x - 1, y], [x + 1, y]]) {
                                    if (nutrientMats.includes(this.get(nx, ny))) {
                                        hasNutrient = true;
                                        break;
                                    }
                                }
                                if (hasNutrient && Math.random() < 0.02) {
                                    const growChoices = [
                                        [x, y - 1], [x, y + 1], [x - 1, y], [x + 1, y],
                                        [x - 1, y - 1], [x + 1, y - 1], [x - 1, y + 1], [x + 1, y + 1]
                                    ].filter(([gx, gy]) => emptyIn(newGrid, gx, gy));
                                    if (growChoices.length > 0) {
                                        const [gx, gy] = growChoices[Math.floor(Math.random() * growChoices.length)];
                                        newGrid[this.getIndex(gx, gy)] = MATERIAL.BACTERIA;
                                    }
                                }
                            }
                        }

                        // Flow behavior for dust and liquids (skip if particle was transformed, e.g. bacteria killed)
                        if (newGrid[idx] !== material) { moved = true; } // Already transformed, skip flow
                        else if (props.flow) {
                            // STEAM, FIRE, EMBER, and ANTIMATTER_BLAST rise instead of fall
                            if (material === MATERIAL.STEAM || material === MATERIAL.FIRE || material === MATERIAL.EMBER || material === MATERIAL.ANTIMATTER_BLAST) {
                                if (emptyIn(newGrid, x, y - 1)) {
                                    const targetIdx = this.getIndex(x, y - 1);
                                    newGrid[targetIdx] = material;
                                    newGrid[idx] = MATERIAL.EMPTY;
                                    moved = true;
                                }
                                else if (emptyIn(newGrid, x - 1, y - 1) || emptyIn(newGrid, x + 1, y - 1)) {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    const nx = x + (emptyIn(newGrid, x + dir, y - 1) ? dir : -dir);
                                    if (emptyIn(newGrid, nx, y - 1)) {
                                        const targetIdx = this.getIndex(nx, y - 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    }
                                }
                                else {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    if (emptyIn(newGrid, x + dir, y)) {
                                        const targetIdx = this.getIndex(x + dir, y);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    }
                                }
                            }
                            // SLIME is viscous - moves slowly
                            else if (material === MATERIAL.SLIME) {
                                if (Math.random() < 0.3) {
                                    if (emptyIn(newGrid, x, y + 1)) {
                                        const targetIdx = this.getIndex(x, y + 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    } else if (emptyIn(newGrid, x - 1, y + 1) || emptyIn(newGrid, x + 1, y + 1)) {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        const nx = x + (emptyIn(newGrid, x + dir, y + 1) ? dir : -dir);
                                        if (emptyIn(newGrid, nx, y + 1)) {
                                            const targetIdx = this.getIndex(nx, y + 1);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    } else {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        if (emptyIn(newGrid, x + dir, y)) {
                                            const targetIdx = this.getIndex(x + dir, y);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    }
                                }
                            }
                            // HONEY is very viscous - even slower than slime
                            else if (material === MATERIAL.HONEY) {
                                if (Math.random() < 0.15) {
                                    if (emptyIn(newGrid, x, y + 1)) {
                                        const targetIdx = this.getIndex(x, y + 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        moved = true;
                                    } else if (emptyIn(newGrid, x - 1, y + 1) || emptyIn(newGrid, x + 1, y + 1)) {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        const nx = x + (emptyIn(newGrid, x + dir, y + 1) ? dir : -dir);
                                        if (emptyIn(newGrid, nx, y + 1)) {
                                            const targetIdx = this.getIndex(nx, y + 1);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    } else {
                                        const dir = Math.random() < 0.5 ? -1 : 1;
                                        if (emptyIn(newGrid, x + dir, y)) {
                                            const targetIdx = this.getIndex(x + dir, y);
                                            newGrid[targetIdx] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            moved = true;
                                        }
                                    }
                                }
                            }
                            else {
                                if (emptyIn(newGrid, x, y + 1)) {
                                    const targetIdx = this.getIndex(x, y + 1);
                                    newGrid[targetIdx] = material;
                                    newGrid[idx] = MATERIAL.EMPTY;
                                    newVelY[targetIdx] = newVY;
                                    newVelX[targetIdx] = newVX;
                                    if (material === MATERIAL.DUST && this.particleAge[idx] > 0) {
                                        this.particleAge[targetIdx] = this.particleAge[idx];
                                        this.particleAge[idx] = 0;
                                    }
                                    moved = true;
                                }
                                else if (emptyIn(newGrid, x - 1, y + 1) || emptyIn(newGrid, x + 1, y + 1)) {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    const nx = x + (emptyIn(newGrid, x + dir, y + 1) ? dir : -dir);
                                    if (emptyIn(newGrid, nx, y + 1)) {
                                        const targetIdx = this.getIndex(nx, y + 1);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelY[targetIdx] = newVY;
                                        newVelX[targetIdx] = newVX;
                                        if (material === MATERIAL.DUST && this.particleAge[idx] > 0) {
                                            this.particleAge[targetIdx] = this.particleAge[idx];
                                            this.particleAge[idx] = 0;
                                        }
                                        moved = true;
                                    }
                                }
                                else if (material === MATERIAL.LIQUID || material === MATERIAL.LAVA || 
                                         material === MATERIAL.ACID || material === MATERIAL.OIL || 
                                         material === MATERIAL.BLOOD || material === MATERIAL.MILK || material === MATERIAL.MERCURY) {
                                    const dir = Math.random() < 0.5 ? -1 : 1;
                                    if (emptyIn(newGrid, x + dir, y)) {
                                        const targetIdx = this.getIndex(x + dir, y);
                                        newGrid[targetIdx] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelX[targetIdx] = dir * (material === MATERIAL.LAVA ? 1 : material === MATERIAL.MERCURY ? 1 : 2);
                                        moved = true;
                                    }
                                }
                            }
                        }
                        // Solid materials check for support
                        else {
                            // SLIME/HONEY/GLUE_METAL/TRAPDOOR: Any block touching these is stuck - won't fall (floating!)
                            const touchingSticky = this.get(x, y - 1) === MATERIAL.SLIME || this.get(x, y - 1) === MATERIAL.HONEY || this.get(x, y - 1) === MATERIAL.GLUE_METAL || this.get(x, y - 1) === MATERIAL.TRAPDOOR ||
                                                  this.get(x, y + 1) === MATERIAL.SLIME || this.get(x, y + 1) === MATERIAL.HONEY || this.get(x, y + 1) === MATERIAL.GLUE_METAL || this.get(x, y + 1) === MATERIAL.TRAPDOOR ||
                                                  this.get(x - 1, y) === MATERIAL.SLIME || this.get(x - 1, y) === MATERIAL.HONEY || this.get(x - 1, y) === MATERIAL.GLUE_METAL || this.get(x - 1, y) === MATERIAL.TRAPDOOR ||
                                                  this.get(x + 1, y) === MATERIAL.SLIME || this.get(x + 1, y) === MATERIAL.HONEY || this.get(x + 1, y) === MATERIAL.GLUE_METAL || this.get(x + 1, y) === MATERIAL.TRAPDOOR;
                            
                            // STICKY BLOCKS: Human-built blocks are sticky; PLANTS need ground support
                            const isHumanBuilt = this.humanBuiltBlocks[idx];
                            
                            const hasDirectSupport = !emptyIn(newGrid, x, y + 1);
                            
                            if (!hasDirectSupport && !touchingSticky) {
                                if (material === MATERIAL.PLANT) {
                                    if (emptyIn(newGrid, x, y + 1)) {
                                        const ti = this.getIndex(x, y + 1);
                                        newGrid[ti] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelY[ti] = newVY;
                                        this.plantType[ti] = this.plantType[idx];
                                        this.plantType[idx] = 0;
                                        moved = true;
                                    }
                                }
                                else if (isHumanBuilt) {
                                    const hasLeftNeighbor = !emptyIn(newGrid, x - 1, y);
                                    const hasRightNeighbor = !emptyIn(newGrid, x + 1, y);
                                    const hasTopNeighbor = !emptyIn(newGrid, x, y - 1);
                                    const hasAnyConnection = hasLeftNeighbor || hasRightNeighbor || hasTopNeighbor;
                                    
                                    if (!hasAnyConnection && emptyIn(newGrid, x, y + 1)) {
                                        const ti = this.getIndex(x, y + 1);
                                        newGrid[ti] = material;
                                        newGrid[idx] = MATERIAL.EMPTY;
                                        newVelY[ti] = newVY;
                                        this.humanBuiltBlocks[ti] = true;
                                        this.humanBuiltBlocks[idx] = false;
                                        moved = true;
                                    }
                                } else {
                                    const leftSupport = !emptyIn(newGrid, x - 1, y) && !emptyIn(newGrid, x - 1, y + 1);
                                    const rightSupport = !emptyIn(newGrid, x + 1, y) && !emptyIn(newGrid, x + 1, y + 1);
                                    
                                    if ((!leftSupport && !rightSupport) || Math.random() < 0.02) {
                                        if (emptyIn(newGrid, x, y + 1)) {
                                            const ti = this.getIndex(x, y + 1);
                                            newGrid[ti] = material;
                                            newGrid[idx] = MATERIAL.EMPTY;
                                            newVelY[ti] = newVY;
                                            moved = true;
                                        }
                                    }
                                }
                            }
                        }

                        if (!moved) {
                            newVelY[idx] = 0;
                            newVelX[idx] = 0;
                    }
                }
                // Density-based liquid layering: swap vertical pairs where heavier is above lighter
                for (let py = 0; py < GRID_HEIGHT - 1; py++) {
                    for (let px = 0; px < GRID_WIDTH; px++) {
                        const uIdx = this.getIndex(px, py);
                        const dIdx = this.getIndex(px, py + 1);
                        if (uIdx === -1 || dIdx === -1) continue;
                        const upper = newGrid[uIdx];
                        const lower = newGrid[dIdx];
                        const upProps = MATERIAL_PROPS[upper];
                        const loProps = MATERIAL_PROPS[lower];
                        if (upper !== MATERIAL.EMPTY && lower !== MATERIAL.EMPTY &&
                            upProps && upProps.flow && loProps && loProps.flow &&
                            !upProps.rises && !loProps.rises &&
                            (upProps.density || 0) > (loProps.density || 0) && Math.random() < 0.4) {
                            newGrid[uIdx] = lower;
                            newGrid[dIdx] = upper;
                            const vx = newVelX[uIdx], vy = newVelY[uIdx];
                            newVelX[uIdx] = newVelX[dIdx]; newVelY[uIdx] = newVelY[dIdx];
                            newVelX[dIdx] = vx; newVelY[dIdx] = vy;
                        }
                    }
                }
                this.grid = newGrid;
                this.velocityX = newVelX;
                this.velocityY = newVelY;
            }



            // Mouse destruction
            destroyAtMouse() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const radius = CONFIG.destroyRadius / CONFIG.pixelSize;
                const now = Date.now();
                const changes = [];

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const x = mx + dx;
                            const y = my + dy;
                            const material = this.get(x, y);
                            
                            if (material !== MATERIAL.EMPTY) {
                                if (material === MATERIAL.LEAD && this.isPartOfLeadBall(x, y)) continue;
                                if (material === MATERIAL.PLAYER_HEAD || material === MATERIAL.PLAYER_BODY) continue;
                                const destroyChance = 1.0 - (dist / radius) * 0.6;
                                if (Math.random() < destroyChance) {
                                    const state = this.captureCellState(x, y);
                                    if (state) changes.push(state);
                                    const idx = this.getIndex(x, y);
                                    if (this.gameMode === 'survival') this.addToInventory(material);
                                    if (Math.random() < 0.5) {
                                        this.set(x, y, MATERIAL.DUST);
                                        const angle = Math.atan2(dy, dx);
                                        this.velocityX[idx] = Math.cos(angle) * (4 + Math.random() * 2);
                                        this.velocityY[idx] = Math.sin(angle) * (4 + Math.random() * 2);
                                        // Set timestamp for debris to disappear after 2 seconds
                                        this.particleAge[idx] = now;
                                    } else {
                                        this.set(x, y, MATERIAL.EMPTY);
                                    }
                                    // Clear flags when destroyed
                                    if (idx !== -1) {
                                        this.humanBuiltBlocks[idx] = false;
                                        this.plantType[idx] = 0;
                                        if (material === MATERIAL.TRAPDOOR) this.trapdoorIndices.delete(idx);
                                        if (material === MATERIAL.WATER_SPOUT || material === MATERIAL.LAVA_SPOUT) this.spoutIndices.delete(idx);
                                    }
                                }
                            }
                        }
                    }
                }
                if (changes.length > 0) {
                    this.undoHistory.push({ type: 'destroy', changes });
                    if (this.undoHistory.length > this.maxUndoHistory) this.undoHistory.shift();
                }
            }

            // Place material along a line (Bresenham) - for Shift+drag line tool
            placeLine(x0, y0, x1, y1, material) {
                const changes = [];
                const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
                const dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
                let lineLen = 0;
                for (let ex = x0, ey = y0, e = dx + dy;;) {
                    lineLen++;
                    if (ex === x1 && ey === y1) break;
                    const e2 = 2 * e;
                    if (e2 >= dy) { e += dy; ex += sx; }
                    if (e2 <= dx) { e += dx; ey += sy; }
                }
                if (this.gameMode === 'survival' && !this.consumeFromInventory(material, lineLen)) return;
                let err = dx + dy;
                let px = x0, py = y0;
                while (true) {
                    const idx = this.getIndex(px, py);
                    if (idx >= 0) {
                        const state = this.captureCellState(px, py);
                        if (state) changes.push(state);
                        this.grid[idx] = material;
                        if (material === MATERIAL.TRAPDOOR) this.trapdoorIndices.add(idx);
                        if (material === MATERIAL.WATER_SPOUT) this.spoutIndices.set(idx, MATERIAL.LIQUID);
                        if (material === MATERIAL.LAVA_SPOUT) this.spoutIndices.set(idx, MATERIAL.LAVA);
                        this.notifyMaterialPlacedAt(px, py, material);
                        if (this.gameMode === 'survival') this.blocksPlaced = (this.blocksPlaced || 0) + 1;
                    }
                    if (px === x1 && py === y1) break;
                    const e2 = 2 * err;
                    if (e2 >= dy) { err += dy; px += sx; }
                    if (e2 <= dx) { err += dx; py += sy; }
                }
                if (changes.length > 0) {
                    this.undoHistory.push({ type: 'place', changes });
                    if (this.undoHistory.length > this.maxUndoHistory) this.undoHistory.shift();
                }
            }

            // Spawn material at mouse
            spawnMaterial(material) {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                if (this.gameMode === 'survival') {
                    if (!this.consumeFromInventory(material, 1)) return;
                    const state = this.captureCellState(mx, my);
                    if (state) this.undoHistory.push({ type: 'place', changes: [state] });
                    this.set(mx, my, material);
                    this.notifyMaterialPlacedAt(mx, my, material);
                    this.blocksPlaced = (this.blocksPlaced || 0) + 1;
                    const idx = this.getIndex(mx, my);
                    if (idx >= 0) {
                        if (material === MATERIAL.TRAPDOOR) this.trapdoorIndices.add(idx);
                        if (material === MATERIAL.WATER_SPOUT) this.spoutIndices.set(idx, MATERIAL.LIQUID);
                        if (material === MATERIAL.LAVA_SPOUT) this.spoutIndices.set(idx, MATERIAL.LAVA);
                    }
                    return;
                }
                const radius = CONFIG.spawnRadius;
                const changes = [];

                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius && Math.random() < 0.7) {
                            const x = mx + dx, y = my + dy;
                            const state = this.captureCellState(x, y);
                            if (state) changes.push(state);
                            const idx = this.getIndex(x, y);
                            this.set(x, y, material);
                            if (material === MATERIAL.TRAPDOOR && idx >= 0) this.trapdoorIndices.add(idx);
                            if (material === MATERIAL.WATER_SPOUT && idx >= 0) this.spoutIndices.set(idx, MATERIAL.LIQUID);
                            if (material === MATERIAL.LAVA_SPOUT && idx >= 0) this.spoutIndices.set(idx, MATERIAL.LAVA);
                            this.notifyMaterialPlacedAt(x, y, material);
                        }
                    }
                }
                if (changes.length > 0) {
                    this.undoHistory.push({ type: 'place', changes });
                    if (this.undoHistory.length > this.maxUndoHistory) this.undoHistory.shift();
                }
                // When placing trapdoors, close all trapdoors
                if (material === MATERIAL.TRAPDOOR) this.closeAllTrapdoors();
            }

            openAllTrapdoors() {
                for (const idx of this.trapdoorIndices) {
                    if (this.grid[idx] === MATERIAL.TRAPDOOR) this.grid[idx] = MATERIAL.EMPTY;
                }
            }

            closeAllTrapdoors() {
                for (const idx of this.trapdoorIndices) {
                    this.grid[idx] = MATERIAL.TRAPDOOR;
                }
            }

            // Update spawners - detect material in interior, emit from opening (sticky output)
            updateSpawners() {
                for (const s of this.spawnerStructures) {
                    // Scan interior for material (user placed or physics moved it in)
                    let found = false;
                    for (let ix = s.left + 1; ix <= s.right - 1 && !found; ix++) {
                        for (let iy = s.top + 1; iy <= s.bottom - 1 && !found; iy++) {
                            const m = this.get(ix, iy);
                            if (m !== MATERIAL.EMPTY) {
                                const skip = [MATERIAL.HUMAN_HEAD, MATERIAL.HUMAN_BODY, MATERIAL.HUMAN_BODY_BUILDER, MATERIAL.DEAD_HUMAN, MATERIAL.FLY, MATERIAL.WORM, MATERIAL.LEAD, MATERIAL.PELLET, MATERIAL.PLAYER_HEAD, MATERIAL.PLAYER_BODY];
                                if (!skip.includes(m)) { s.material = m; found = true; }
                            }
                        }
                    }
                    if (!s.material) continue;
                    if (this.frameCount % 5 !== 0) continue;
                    const belowIdx = this.getIndex(s.emitX, s.emitY + 1);
                    if (belowIdx === -1) continue;
                    if (this.grid[belowIdx] !== MATERIAL.EMPTY) continue;
                    this.grid[belowIdx] = s.material;
                    this.humanBuiltBlocks[belowIdx] = true;
                }
            }

            // Update spouts - emit liquid downward every few frames
            updateSpouts() {
                if (this.frameCount % 4 !== 0) return; // Emit every 4 frames to avoid flooding
                for (const [idx, liquid] of this.spoutIndices) {
                    const material = this.grid[idx];
                    if (material !== MATERIAL.WATER_SPOUT && material !== MATERIAL.LAVA_SPOUT) {
                        this.spoutIndices.delete(idx);
                        continue;
                    }
                    const x = idx % GRID_WIDTH;
                    const y = Math.floor(idx / GRID_WIDTH);
                    const belowIdx = this.getIndex(x, y + 1);
                    if (belowIdx === -1) continue;
                    const below = this.grid[belowIdx];
                    // Emit into empty, or same liquid, or displace lighter liquids
                    const canEmit = below === MATERIAL.EMPTY || below === liquid;
                    if (canEmit && Math.random() < 0.6) {
                        this.grid[belowIdx] = liquid;
                    }
                }
            }

            // Spawn small plant seeds (1-3 voxels)
            spawnPlant() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                
                // Spawn 1-3 small seed voxels instead of a large circle
                const seedCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < seedCount; i++) {
                    const offsetX = Math.floor(Math.random() * 5) - 2;
                    const offsetY = Math.floor(Math.random() * 5) - 2;
                    const seedX = mx + offsetX;
                    const seedY = my + offsetY;
                    
                    if (this.isEmpty(seedX, seedY)) {
                        this.set(seedX, seedY, MATERIAL.PLANT);
                        const seedIdx = this.getIndex(seedX, seedY);
                        if (seedIdx !== -1) {
                            // Seeds start as green (0), occasionally brown (1)
                            this.plantType[seedIdx] = Math.random() < 0.2 ? 1 : 0;
                        }
                    }
                }
            }

            // Spawn a normal human (2 voxels: pink head, blue shirt) - does NOT build
            spawnHuman() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                
                if (this.isEmpty(mx, my) && this.isEmpty(mx, my - 1)) {
                    const humanId = this.nextHumanId++;
                    this.set(mx, my, MATERIAL.HUMAN_BODY);
                    this.set(mx, my - 1, MATERIAL.HUMAN_HEAD);
                    
                    this.humans.push({
                        id: humanId,
                        headX: mx,
                        headY: my - 1,
                        bodyX: mx,
                        bodyY: my,
                        alive: true,
                        vx: 0,
                        vy: 0,
                        direction: Math.random() < 0.5 ? -1 : 1,
                        justBuilt: false,
                        isBuilder: false
                    });
                }
            }

            // Spawn human feces (attracts flies)
            spawnFeces() {
                this.spawnMaterial(MATERIAL.FEECES);
            }

            // Spawn a fly (or several) - life form attracted to feces
            spawnFly() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const count = Math.floor(Math.random() * 3) + 2; // 2-4 flies
                for (let i = 0; i < count; i++) {
                    const offsetX = Math.floor(Math.random() * 7) - 3;
                    const offsetY = Math.floor(Math.random() * 7) - 3;
                    const fx = mx + offsetX;
                    const fy = my + offsetY;
                    if (fx >= 0 && fx < GRID_WIDTH && fy >= 0 && fy < GRID_HEIGHT && this.isEmpty(fx, fy)) {
                        this.set(fx, fy, MATERIAL.FLY);
                        this.flies.push({
                            id: this.nextFlyId++,
                            x: fx,
                            y: fy,
                            alive: true
                        });
                    }
                }
            }

            // Spawn a builder human (2 voxels: pink head, yellow shirt) - builds at edges
            spawnBuilderHuman() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                
                if (this.isEmpty(mx, my) && this.isEmpty(mx, my - 1)) {
                    const humanId = this.nextHumanId++;
                    this.set(mx, my, MATERIAL.HUMAN_BODY_BUILDER);
                    this.set(mx, my - 1, MATERIAL.HUMAN_HEAD);
                    
                    this.humans.push({
                        id: humanId,
                        headX: mx,
                        headY: my - 1,
                        bodyX: mx,
                        bodyY: my,
                        alive: true,
                        vx: 0,
                        vy: 0,
                        direction: Math.random() < 0.5 ? -1 : 1,
                        justBuilt: false,
                        isBuilder: true
                    });
                }
            }

            // Spawn quick structures - place pre-built shapes for building
            spawnBridge() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // 12-wide concrete bridge, 2 thick - sticky so it floats as one piece
                for (let dx = -6; dx <= 5; dx++) {
                    for (let dy = 0; dy <= 1; dy++) {
                        const x = mx + dx, y = my + dy;
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                            const idx = this.getIndex(x, y);
                            this.set(x, y, MATERIAL.CONCRETE);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }
            spawnTower() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // 4x4 base, 20 blocks tall tower - concrete with metal corners - sticky so it floats as one piece
                const h = 20;
                for (let by = 0; by < h; by++) {
                    for (let bx = -2; bx <= 1; bx++) {
                        const x = mx + bx, y = my + by;
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                            const isEdge = bx === -2 || bx === 1 || by === 0 || by === h - 1;
                            const idx = this.getIndex(x, y);
                            this.set(x, y, isEdge ? MATERIAL.METAL : MATERIAL.CONCRETE);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }
            spawnArch() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // Stone arch - curved top, two pillars (centered on click) - sticky so it floats as one piece
                const shape = [
                    [0,3],[1,3],[2,3],[3,3],[4,3],[5,3],[6,3],[7,3],[8,3],
                    [1,2],[2,2],[3,2],[4,2],[5,2],[6,2],[7,2],
                    [2,1],[3,1],[4,1],[5,1],[6,1],
                    [3,0],[4,0],[5,0],
                    [4,-1],
                    [0,4],[0,5],[1,4],[1,5],[7,4],[7,5],[8,4],[8,5]
                ];
                for (const [dx, dy] of shape) {
                    const x = mx + dx - 4, y = my + dy;
                    if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                        const idx = this.getIndex(x, y);
                        this.set(x, y, MATERIAL.STONE);
                        if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                    }
                }
            }

            // Spawner - hollow square: put material inside, it emits it (sticky output)
            spawnSpawner() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const left = mx - 2, right = mx + 2, top = my - 2, bottom = my + 2;
                const emitX = mx, emitY = bottom;
                // 5x5 hollow square - walls are concrete, interior empty, opening at bottom center
                for (let x = left; x <= right; x++) {
                    for (let y = top; y <= bottom; y++) {
                        if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) continue;
                        const isTop = y === top;
                        const isBottom = y === bottom;
                        const isLeft = x === left;
                        const isRight = x === right;
                        const isOpening = isBottom && x === mx;
                        if ((isTop || isBottom || isLeft || isRight) && !isOpening) {
                            const idx = this.getIndex(x, y);
                            this.set(x, y, MATERIAL.CONCRETE);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
                this.spawnerStructures.push({ left, top, right, bottom, emitX, emitY, material: null });
            }

            // When material is placed, check if it's inside a spawner - if so, set spawner's material
            notifyMaterialPlacedAt(x, y, material) {
                if (material === MATERIAL.EMPTY) return;
                const skipTypes = [MATERIAL.HUMAN_HEAD, MATERIAL.HUMAN_BODY, MATERIAL.HUMAN_BODY_BUILDER, MATERIAL.DEAD_HUMAN, MATERIAL.FLY, MATERIAL.WORM, MATERIAL.LEAD, MATERIAL.PELLET, MATERIAL.PLAYER_HEAD, MATERIAL.PLAYER_BODY];
                if (skipTypes.includes(material)) return;
                for (const s of this.spawnerStructures) {
                    if (x >= s.left + 1 && x <= s.right - 1 && y >= s.top + 1 && y <= s.bottom - 1) {
                        s.material = material;
                        break;
                    }
                }
            }

            spawnStairs() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // Diagonal staircase - 10 steps going up-left
                for (let i = 0; i < 10; i++) {
                    const x = mx + i, y = my - i;
                    for (let wy = 0; wy <= 1; wy++) {
                        const gx = x - wy, gy = y + wy;
                        if (gx >= 0 && gx < GRID_WIDTH && gy >= 0 && gy < GRID_HEIGHT) {
                            const idx = this.getIndex(gx, gy);
                            this.set(gx, gy, MATERIAL.CONCRETE);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }
            spawnWall() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // Vertical wall - 3 wide, 15 tall, stone with concrete base
                const w = 3, h = 15;
                for (let by = 0; by < h; by++) {
                    for (let bx = -1; bx <= 1; bx++) {
                        const x = mx + bx, y = my + by;
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                            const idx = this.getIndex(x, y);
                            const mat = by < 2 ? MATERIAL.CONCRETE : MATERIAL.STONE;
                            this.set(x, y, mat);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }
            spawnPlatform() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // Floating wooden platform - 8 wide, 2 thick
                for (let dx = -4; dx <= 3; dx++) {
                    for (let dy = 0; dy <= 1; dy++) {
                        const x = mx + dx, y = my + dy;
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                            const idx = this.getIndex(x, y);
                            this.set(x, y, MATERIAL.WOOD);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }
            spawnPyramid() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // Small stone pyramid - 5 layers
                for (let layer = 0; layer < 5; layer++) {
                    const width = 9 - layer * 2;
                    const startX = -Math.floor(width / 2);
                    for (let dx = 0; dx < width; dx++) {
                        const x = mx + startX + dx, y = my + layer;
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                            const idx = this.getIndex(x, y);
                            this.set(x, y, MATERIAL.STONE);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }
            spawnPillar() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                // Tall narrow pillar - 2x2 base, 25 blocks tall, metal frame
                const h = 25;
                for (let by = 0; by < h; by++) {
                    for (let bx = -1; bx <= 0; bx++) {
                        const x = mx + bx, y = my + by;
                        if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                            const idx = this.getIndex(x, y);
                            const isEdge = bx === -1 || bx === 0 || by === 0 || by === h - 1;
                            this.set(x, y, isEdge ? MATERIAL.METAL : MATERIAL.GLASS);
                            if (idx >= 0) this.humanBuiltBlocks[idx] = true;
                        }
                    }
                }
            }

            // Spawn pellets (shotgun spread - 5-7 light projectiles, launched in spread by gunpowder)
            spawnPellets() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const count = 5 + Math.floor(Math.random() * 3);
                const spread = [[0,0], [-1,0], [1,0], [-1,-1], [1,-1], [-2,0], [2,0]];
                for (let i = 0; i < count && i < spread.length; i++) {
                    const [dx, dy] = spread[i];
                    const px = mx + dx, py = my + dy;
                    if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT && this.isEmpty(px, py)) {
                        this.set(px, py, MATERIAL.PELLET);
                        this.pelletBalls.push({
                            id: this.nextPelletId++,
                            cx: px, cy: py, vx: 0, vy: 0
                        });
                    }
                }
            }

            // Spawn a lead ball (sticky cluster, launched by gunpowder, kills humans on impact)
            spawnLeadBall() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                const shape = this._leadShape || (this._leadShape = this.getLeadBallShape());
                const allEmpty = shape.every(v => this.isEmpty(mx + v.x, my + v.y));
                if (allEmpty) {
                    for (const v of shape) this.set(mx + v.x, my + v.y, MATERIAL.LEAD);
                    this.leadBalls.push({
                        id: this.nextLeadBallId++,
                        cx: mx,
                        cy: my,
                        voxels: shape,
                        vx: 0,
                        vy: 0
                    });
                }
            }

            // Spawn glue metal (sticky metal - adjacent blocks won't fall)
            spawnGlueMetal() {
                this.spawnMaterial(MATERIAL.GLUE_METAL);
            }

            // Spawn a worm (1 pink moving particle)
            spawnWorm() {
                const mx = Math.floor(this.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(this.mouse.y / CONFIG.pixelSize);
                if (this.isEmpty(mx, my)) {
                    this.set(mx, my, MATERIAL.WORM);
                    this.worms.push({ id: this.nextWormId++, x: mx, y: my, vx: 0, vy: 0 });
                }
            }

            // Count active particles
            countParticles() {
                this.particleCount = this.grid.filter(m => m !== MATERIAL.EMPTY).length;
            }

            // Update game state
            update() {
                this.simulate();

                // FPS counter
                this.frameCount++;
                const now = Date.now();
                if (now - this.lastFpsUpdate > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
            }

            // Render the game
            render() {
                // CLEAR EVERYTHING - no trails, no artifacts
                ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
                
                // Sky background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.height);
                gradient.addColorStop(0, '#87ceeb');
                gradient.addColorStop(1, '#b8d8eb');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);

                // Plant color palette: 0=green, 1=brown, 2=yellow, 3=red, 4=pink, 5=orange, 6=magenta
                const PLANT_COLORS = [
                    [34, 139, 34],   // 0: forest green (leaves)
                    [139, 90, 43],   // 1: saddle brown (stems)
                    [255, 255, 0],   // 2: yellow (flower)
                    [255, 80, 80],   // 3: coral red (flower)
                    [255, 182, 193], // 4: light pink (flower)
                    [255, 165, 0],   // 5: orange (flower)
                    [255, 0, 255]    // 6: magenta (flower)
                ];

                const t = Date.now();
                const ps = CONFIG.pixelSize;
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const material = this.get(x, y);
                        if (material === MATERIAL.EMPTY) continue;

                        const props = MATERIAL_PROPS[material];
                        let base = props.shadeBase;
                        if (material === MATERIAL.PLANT) {
                            const pType = this.plantType[this.getIndex(x, y)] || 0;
                            base = PLANT_COLORS[Math.min(pType, 6)];
                        }

                        const hasTop = !this.isEmpty(x, y - 1);
                        const hasBottom = !this.isEmpty(x, y + 1);
                        const hasLeft = !this.isEmpty(x - 1, y);
                        const hasRight = !this.isEmpty(x + 1, y);

                        let shade = 0;
                        if (!hasTop) shade += 20;
                        if (!hasLeft) shade += 10;
                        if (hasBottom && !hasTop) shade += 8;
                        if (!hasRight) shade -= 10;
                        if (!hasBottom) shade -= 15;

                        let noise = (((x * 31 + y * 17) % 101) / 101 - 0.5) * 12;
                        if (material === MATERIAL.LAVA) noise += Math.sin(t * 0.003 + x * 0.5 + y * 0.5) * 15;
                        else if (material === MATERIAL.ACID) noise += Math.sin(t * 0.008 + x + y) * 25;
                        else if (material === MATERIAL.FIRE) noise += Math.sin(t * 0.01 + x + y * 2) * 40;
                        else if (material === MATERIAL.SLIME) noise += Math.sin(t * 0.002 + x * 0.3 + y * 0.3) * 10;
                        else if (material === MATERIAL.EMBER) noise += Math.sin(t * 0.012 + x + y * 2) * 35;
                        else if (material === MATERIAL.HONEY) noise += Math.sin(x * 0.4 + y * 0.6) * 8;
                        else if (material === MATERIAL.FLY) noise += Math.sin(t * 0.02 + x * 2 + y * 2) * 15;
                        else if (material === MATERIAL.WORM) noise += Math.sin(t * 0.025 + x * 1.5 + y * 1.5) * 12;
                        else if (material === MATERIAL.MERCURY) noise += Math.sin(t * 0.002 + x * 0.6 + y * 0.6) * 18;
                        else if (material === MATERIAL.ANTIMATTER) noise += Math.sin(t * 0.004 + x * 0.5 + y * 0.5) * 20;
                        else if (material === MATERIAL.ANTIMATTER_BLAST) {
                            noise += Math.sin(t * 0.015 + x + y * 2) * 45;
                            // Purple-blue variation based on position
                            base = (base[0] + Math.sin(x * 0.3 + y * 0.2) * 40 > 128) ? [160, 60, 255] : [80, 100, 255];
                        }
                        else if (material === MATERIAL.BACTERIA) noise += Math.sin(t * 0.015 + x * 2 + y * 2) * 8;
                        else if (material === MATERIAL.PLANT) {
                            const pType = this.plantType[this.getIndex(x, y)] || 0;
                            noise += pType >= 2 ? Math.sin(x * 0.5 + y * 0.8) * 8
                                : Math.sin(x * 0.7 + y * 1.3) * 15 + Math.cos(x * 1.1 + y * 0.9) * 10;
                        }

                        const r = Math.max(0, Math.min(255, base[0] + shade + noise));
                        const g = Math.max(0, Math.min(255, base[1] + shade + noise));
                        const b = Math.max(0, Math.min(255, base[2] + shade + noise));

                        let fillStyle = material === MATERIAL.STEAM ? `rgba(${r},${g},${b},0.5)` : `rgb(${r},${g},${b})`;
                        if (material === MATERIAL.ANTIMATTER_BLAST) fillStyle = `rgba(${r},${g},${b},0.85)`;
                        ctx.fillStyle = fillStyle;
                        ctx.fillRect(x * ps, y * ps, ps, ps);
                    }
                }

                // Draw SINGLE custom cursor - ONLY when mouse is actually in canvas
                if (this.mouse.isInCanvas) {
                    const mx = this.mouse.x;
                    const my = this.mouse.y;
                    const isDestroy = this.mouse.rightDown || (destroyModeActive && this.mouse.down) || (this.gameMode === 'survival' && survivalDigMode && this.mouse.down);
                    const isPlace = this.mouse.down && !isDestroy;
                    
                    // Outer circle (red=destroy, green=place, white=idle)
                    let stroke = 'rgba(255, 255, 255, 0.7)';
                    let fill = 'rgba(255, 255, 255, 0.8)';
                    if (isDestroy) { stroke = 'rgba(255, 80, 80, 0.9)'; fill = 'rgba(255, 60, 60, 0.9)'; }
                    else if (isPlace) { stroke = 'rgba(78, 205, 196, 0.9)'; fill = 'rgba(78, 205, 196, 0.8)'; }
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(mx, my, CONFIG.destroyRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Crosshair lines
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = 2;
                    const crossSize = 10;
                    ctx.beginPath();
                    ctx.moveTo(mx - crossSize, my);
                    ctx.lineTo(mx + crossSize, my);
                    ctx.moveTo(mx, my - crossSize);
                    ctx.lineTo(mx, my + crossSize);
                    ctx.stroke();
                    
                    // Center dot
                    ctx.fillStyle = fill;
                    ctx.beginPath();
                    ctx.arc(mx, my, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Update UI
                this.countParticles();
                document.getElementById('particleCount').textContent = this.particleCount.toLocaleString();
                const destruction = this.initialParticles > 0 
                    ? Math.floor((1 - this.particleCount / this.initialParticles) * 100)
                    : 0;
                document.getElementById('destructionPercent').textContent = Math.max(0, destruction);
                document.getElementById('fps').textContent = this.fps;

            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
        }

        // Initialize game
        const game = new Game();
        game.generateBuildings();

        document.querySelector('.modeBtn.sandbox').addEventListener('click', () => {
            document.getElementById('mainMenu').classList.add('hidden');
            game.gameMode = 'sandbox';
            game.player = null;
            game.inventory = {};
            survivalDigMode = false;
            document.getElementById('craftingPanel').classList.remove('open');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('materialMenu').classList.remove('hidden');
            document.getElementById('settings').classList.remove('hidden');
            document.getElementById('currentMaterialDisplay').classList.remove('hidden');
            game.grid.fill(MATERIAL.EMPTY);
            game.humanBuiltBlocks.fill(false);
            game.plantType.fill(0);
            game.humans = []; game.flies = []; game.leadBalls = []; game.pelletBalls = []; game.worms = [];
            game.trapdoorIndices.clear();
            game.spoutIndices.clear();
            game.spawnerStructures = [];
            game.generateBuildings();
        });

        function startSurvivalMode() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('settings').classList.remove('mainMenuOverlay');
            game.gameMode = 'survival';
            game.inventory = {};
            game.grid.fill(MATERIAL.EMPTY);
            game.humanBuiltBlocks.fill(false);
            game.plantType.fill(0);
            game.humans = []; game.flies = []; game.leadBalls = []; game.pelletBalls = []; game.worms = [];
            game.trapdoorIndices.clear();
            game.spoutIndices.clear();
            game.spawnerStructures = [];
            game.generateTerrain();
            hideAllUIForSurvival();
            renderCraftingPanel();
        }

        document.querySelector('.modeBtn.survival').addEventListener('click', () => {
            // Survival only starts via command - open settings and focus command input
            const settingsEl = document.getElementById('settings');
            settingsEl.classList.remove('hidden');
            settingsEl.classList.add('mainMenuOverlay');
            settingsEl.classList.remove('collapsed');
            settingsCollapsed = false;
            document.getElementById('settingsCollapseBtn').textContent = '‚àí';
            document.getElementById('settingsCommand').focus();
        });

        document.getElementById('mainMenuSettingsBtn').addEventListener('click', () => {
            const settingsEl = document.getElementById('settings');
            settingsEl.classList.toggle('hidden');
            if (!settingsEl.classList.contains('hidden')) {
                settingsEl.classList.add('mainMenuOverlay');
                settingsEl.classList.remove('collapsed');
                settingsCollapsed = false;
                document.getElementById('settingsCollapseBtn').textContent = '‚àí';
                document.getElementById('settingsCommand').focus();
            } else {
                settingsEl.classList.remove('mainMenuOverlay');
            }
        });

        const settingsCommandInput = document.getElementById('settingsCommand');
        settingsCommandInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const cmd = (settingsCommandInput.value || '').trim().toLowerCase();
                if (cmd === 'survivalstart') {
                    settingsCommandInput.value = '';
                    startSurvivalMode();
                }
            }
        });

        window.addEventListener('keydown', (e) => {
            if (game.gameMode === 'survival' && ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','a','A','d','D','w','W','s','S'].includes(e.key)) {
                e.preventDefault();
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') game.playerKeys.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') game.playerKeys.right = true;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') game.playerKeys.up = true;
                if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') game.playerKeys.down = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','a','A','d','D','w','W','s','S'].includes(e.key)) {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') game.playerKeys.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') game.playerKeys.right = false;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') game.playerKeys.up = false;
                if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') game.playerKeys.down = false;
            }
        });

        function hideAllUIForSurvival() {
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('materialMenu').classList.add('hidden');
            document.getElementById('settings').classList.add('hidden');
            document.getElementById('currentMaterialDisplay').classList.add('hidden');
        }

        const SURVIVAL_GOAL = 20;
        const CRAFT_RECIPES = [
            { inputs: [[MATERIAL.SAND, 3]], output: MATERIAL.GLASS },
            { inputs: [[MATERIAL.STONE, 2], [MATERIAL.SAND, 1]], output: MATERIAL.CONCRETE },
            { inputs: [[MATERIAL.STONE, 4]], output: MATERIAL.METAL },
            { inputs: [[MATERIAL.DUST, 2]], output: MATERIAL.SAND },
            { inputs: [[MATERIAL.SAND, 2]], output: MATERIAL.DUST },
            { inputs: [[MATERIAL.ICE, 1]], output: MATERIAL.LIQUID },
            { inputs: [[MATERIAL.GRAVEL, 2], [MATERIAL.SAND, 1]], output: MATERIAL.CONCRETE },
            { inputs: [[MATERIAL.WOOD, 2]], output: MATERIAL.CONCRETE }
        ];

        let survivalSelectedMaterial = null;
        let craftingPanelOpen = false;
        let survivalDigMode = false;  // B toggles: left-click destroys (like sandbox)

        function renderCraftingPanel() {
            const invList = document.getElementById('craftingInventoryList');
            const recipeList = document.getElementById('craftingRecipeList');
            const heartsEl = document.getElementById('craftingHearts');
            const goalEl = document.getElementById('craftingGoal');
            if (!invList) return;
            const placed = game.blocksPlaced || 0;
            const goalDone = placed >= SURVIVAL_GOAL;
            if (goalEl) goalEl.innerHTML = goalDone
                ? '<div style="color:#4ade80;font-weight:bold;padding:6px;background:#1a2a1a;border:1px solid #4ade80;margin-bottom:8px;">‚úì Goal complete! Shelter built.</div>'
                : '<div style="color:#fbbf24;padding:6px;background:#2a2a1a;border:1px solid #555;margin-bottom:8px;">Goal: Build your shelter ‚Äî ' + placed + '/' + SURVIVAL_GOAL + ' blocks placed</div>';
            invList.innerHTML = '';
            const gatherable = [MATERIAL.CONCRETE, MATERIAL.STONE, MATERIAL.METAL, MATERIAL.GLASS, MATERIAL.WOOD, MATERIAL.SAND, MATERIAL.DUST, MATERIAL.GRAVEL, MATERIAL.ICE, MATERIAL.LIQUID, MATERIAL.PLANT, MATERIAL.SNOW, MATERIAL.LAVA, MATERIAL.OIL, MATERIAL.STEAM, MATERIAL.SLIME, MATERIAL.GUNPOWDER, MATERIAL.FUSE, MATERIAL.RUBBER, MATERIAL.GLUE_METAL, MATERIAL.TRAPDOOR, MATERIAL.WATER_SPOUT, MATERIAL.LAVA_SPOUT, MATERIAL.ANTIMETAL, MATERIAL.HONEY];
            for (const m of gatherable) {
                const count = game.inventory[m] || 0;
                if (count <= 0) continue;
                const div = document.createElement('div');
                div.className = 'craftSlot' + (survivalSelectedMaterial === m ? ' selected' : '');
                div.innerHTML = '<div class="colorBox" style="background:' + (MATERIAL_PROPS[m].color || '#888') + '"></div><span class="name">' + (MATERIAL_LABELS[m] || '?') + '</span><span class="count">√ó' + count + '</span>';
                div.onclick = () => { survivalSelectedMaterial = m; renderCraftingPanel(); };
                invList.appendChild(div);
            }
            if (Object.keys(game.inventory).length === 0) invList.innerHTML = '<div class="craftHint">Gather materials by right-click digging.</div>';
            recipeList.innerHTML = '';
            for (const r of CRAFT_RECIPES) {
                const canCraft = r.inputs.every(([mat, n]) => (game.inventory[mat] || 0) >= n);
                const div = document.createElement('div');
                div.className = 'craftRecipe' + (canCraft ? '' : ' cantCraft');
                let inputsHtml = '';
                for (const [mat, n] of r.inputs) inputsHtml += '<div class="colorBox" style="background:' + (MATERIAL_PROPS[mat].color || '#888') + '" title="' + (MATERIAL_LABELS[mat] || '') + '">' + n + '</div>';
                div.innerHTML = '<div class="inputs">' + inputsHtml + '</div><span class="arrow">‚Üí</span><div class="output"><div class="colorBox" style="background:' + (MATERIAL_PROPS[r.output].color || '#888') + '"></div><span>' + (MATERIAL_LABELS[r.output] || '?') + '</span></div>';
                if (canCraft) div.onclick = () => { for (const [mat, n] of r.inputs) game.consumeFromInventory(mat, n); game.addToInventory(r.output); survivalSelectedMaterial = r.output; renderCraftingPanel(); };
                recipeList.appendChild(div);
            }
            if (game.player && !game.player.dead) {
                const hp = game.player.health, max = game.player.maxHealth;
                let hearts = '';
                const full = Math.ceil((hp / max) * 5);
                for (let i = 0; i < 5; i++) hearts += i < full ? '<span style="color:#ef4444">‚ù§</span>' : '<span style="color:#444">‚ô°</span>';
                heartsEl.innerHTML = hearts;
            } else heartsEl.innerHTML = '';
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && game.gameMode === 'survival') {
                e.preventDefault();
                craftingPanelOpen = !craftingPanelOpen;
                document.getElementById('craftingPanel').classList.toggle('open', craftingPanelOpen);
                if (craftingPanelOpen) renderCraftingPanel();
            }
            if (e.key === 'b' || e.key === 'B') {
                if (game.gameMode === 'survival') survivalDigMode = !survivalDigMode;
            }
        });
        
        // Selected material (null = none, or { type: 'material', id }, or { type: 'special', action })
        let selectedMaterial = null;
        
        // Line tool: last position when Shift+drag drawing
        let lastLinePos = null;
        let shiftKeyHeld = false;
        
        // UI visibility state
        let uiVisible = true;
        let materialMenuMinimized = false;
        let destroyModeActive = false;
        let materialMenuPosition = null; // { left, bottom } when dragged, null = centered

        // Build material menu
        function initMaterialMenu() {
            const tabsEl = document.getElementById('materialTabs');
            const contentEl = document.getElementById('materialContent');
            const tabNames = Object.keys(MATERIAL_TABS);
            
            tabNames.forEach((tabName, i) => {
                const tab = document.createElement('span');
                tab.className = 'tab' + (i === 0 ? ' active' : '');
                tab.textContent = tabName;
                tab.dataset.tab = tabName;
                tab.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (materialMenuMinimized) {
                        materialMenuMinimized = false;
                        document.getElementById('materialMenu').classList.remove('minimized');
                        document.getElementById('minimizeBtn').textContent = '‚àí';
                    }
                    tabsEl.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    renderMaterialContent(tabName);
                });
                tabsEl.appendChild(tab);
            });
            
            function renderMaterialContent(tabName) {
                contentEl.innerHTML = '';
                const items = MATERIAL_TABS[tabName];
                items.forEach(item => {
                    const tile = document.createElement('div');
                    tile.className = 'materialTile';
                    if (typeof item === 'object' && item.special) {
                        tile.dataset.special = item.special;
                        tile.innerHTML = `<div class="tileColor" style="background:${item.color}"></div><span class="tileName">${item.label}</span>`;
                        tile.title = item.label;
                    } else {
                        const m = item;
                        const props = MATERIAL_PROPS[m];
                        const label = MATERIAL_LABELS[m] || '?';
                        tile.dataset.material = m;
                        tile.innerHTML = `<div class="tileColor" style="background:${props.color || '#444'}"></div><span class="tileName">${label}</span>`;
                        tile.title = label;
                    }
                    tile.addEventListener('click', (e) => {
                        e.stopPropagation();
                        destroyModeActive = false;
                        document.getElementById('materialDestroyBtn').classList.remove('active');
                        document.querySelectorAll('.materialTile').forEach(t => t.classList.remove('selected'));
                        tile.classList.add('selected');
                        if (typeof item === 'object' && item.special) {
                            selectedMaterial = { type: 'special', action: item.special, label: item.label, color: item.color };
                        } else {
                            selectedMaterial = { type: 'material', id: item, label: MATERIAL_LABELS[item], color: MATERIAL_PROPS[item].color };
                        }
                        updateCurrentMaterialDisplay();
                    });
                    contentEl.appendChild(tile);
                });
            }
            
            renderMaterialContent(tabNames[0]);
            
            // Drag handle - move material menu
            const dragHandle = document.getElementById('materialDragHandle');
            const menuEl = document.getElementById('materialMenu');
            const containerEl = document.getElementById('gameContainer');
            dragHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                const startX = e.clientX;
                const startY = e.clientY;
                const rect = menuEl.getBoundingClientRect();
                const cRect = containerEl.getBoundingClientRect();
                let startLeft = materialMenuPosition ? materialMenuPosition.left : (rect.left - cRect.left);
                let startBottom = materialMenuPosition ? materialMenuPosition.bottom : (cRect.bottom - rect.bottom);
                const onMove = (ev) => {
                    const dx = ev.clientX - startX;
                    const dy = startY - ev.clientY;
                    materialMenuPosition = {
                        left: Math.max(0, Math.min(cRect.width - rect.width, startLeft + dx)),
                        bottom: Math.max(0, Math.min(cRect.height - 40, startBottom + dy))
                    };
                    menuEl.style.left = materialMenuPosition.left + 'px';
                    menuEl.style.bottom = materialMenuPosition.bottom + 'px';
                    menuEl.style.transform = 'none';
                };
                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            // Destroy button - toggle destroy mode (left-click destroys when active)
            const destroyBtn = document.getElementById('materialDestroyBtn');
            destroyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                destroyModeActive = !destroyModeActive;
                destroyBtn.classList.toggle('active', destroyModeActive);
                if (destroyModeActive) {
                    document.querySelectorAll('.materialTile').forEach(t => t.classList.remove('selected'));
                    selectedMaterial = null;
                }
                updateCurrentMaterialDisplay();
            });
            
            // Minimize button
            document.getElementById('minimizeBtn').addEventListener('click', (e) => {
                e.stopPropagation();
                materialMenuMinimized = !materialMenuMinimized;
                document.getElementById('materialMenu').classList.toggle('minimized', materialMenuMinimized);
                e.target.textContent = materialMenuMinimized ? '+' : '‚àí';
            });
            
            // Header click to expand when minimized
            document.getElementById('materialMenuHeader').addEventListener('click', (e) => {
                if (materialMenuMinimized && !e.target.classList.contains('tab') && e.target.id !== 'minimizeBtn' && e.target.id !== 'materialDragHandle' && e.target.id !== 'materialDestroyBtn') {
                    materialMenuMinimized = false;
                    document.getElementById('materialMenu').classList.remove('minimized');
                    document.getElementById('minimizeBtn').textContent = '‚àí';
                }
            });
        }
        
        function updateCurrentMaterialDisplay() {
            const swatch = document.getElementById('currentSwatch');
            const nameEl = document.getElementById('currentMaterialName');
            if (destroyModeActive) {
                swatch.style.background = '#ff6b6b';
                swatch.style.display = 'block';
                nameEl.textContent = 'Destroy';
            } else if (selectedMaterial) {
                swatch.style.background = selectedMaterial.color;
                swatch.style.display = 'block';
                nameEl.textContent = selectedMaterial.label;
            } else {
                swatch.style.display = 'none';
                nameEl.textContent = '‚Äî';
            }
        }
        
        initMaterialMenu();
        updateCurrentMaterialDisplay();
        
        // Collapsible UI and Settings
        let uiCollapsed = false;
        let settingsCollapsed = false;
        
        document.getElementById('uiHeader').addEventListener('click', () => {
            uiCollapsed = !uiCollapsed;
            document.getElementById('ui').classList.toggle('collapsed', uiCollapsed);
            document.getElementById('uiCollapseBtn').textContent = uiCollapsed ? '+' : '‚àí';
        });
        
        document.getElementById('settingsHeader').addEventListener('click', () => {
            settingsCollapsed = !settingsCollapsed;
            document.getElementById('settings').classList.toggle('collapsed', settingsCollapsed);
            document.getElementById('settingsCollapseBtn').textContent = settingsCollapsed ? '+' : '‚àí';
        });

        // Input handling
        window.addEventListener('keydown', (e) => {
            // Backspace: undo most recent material added or broken
            if (e.key === 'Backspace') {
                const target = document.activeElement;
                const isEditable = target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT' || target.isContentEditable);
                if (!isEditable) {
                    e.preventDefault();
                    game.undo();
                }
            }
            // Trapdoors: O = open all, C = close all
            if (e.key === 'o' || e.key === 'O') {
                game.openAllTrapdoors();
            }
            if (e.key === 'c' || e.key === 'C') {
                game.closeAllTrapdoors();
            }
            
            // Rebuild
            if (e.key === 'r' || e.key === 'R') {
                game.grid.fill(MATERIAL.EMPTY);
                game.humanBuiltBlocks.fill(false); // Clear sticky blocks
                game.plantType.fill(0); // Clear plant colors
                game.humans = []; // Clear all humans
                game.nextHumanId = 0;
                game.flies = [];
                game.nextFlyId = 0;
                game.leadBalls = [];
                game.nextLeadBallId = 0;
                game.pelletBalls = [];
                game.nextPelletId = 0;
                game.worms = [];
                game.nextWormId = 0;
                game.undoHistory = [];
                if (game.gameMode === 'survival') {
                    game.inventory = {};
                    game.generateTerrain();
                } else game.generateBuildings();
            }
            
            if (e.key === 'h' || e.key === 'H') {
                if (game.gameMode === 'survival') {
                    craftingPanelOpen = !craftingPanelOpen;
                    document.getElementById('craftingPanel').classList.toggle('open', craftingPanelOpen);
                    if (craftingPanelOpen) renderCraftingPanel();
                } else {
                    uiVisible = !uiVisible;
                    const uiElement = document.getElementById('ui');
                    const materialMenu = document.getElementById('materialMenu');
                    const currentDisplay = document.getElementById('currentMaterialDisplay');
                    const settingsElement = document.getElementById('settings');
                    const indicator = document.getElementById('uiToggleIndicator');
                    if (uiVisible) {
                        uiElement.classList.remove('hidden');
                        materialMenu.classList.remove('hidden');
                        currentDisplay.classList.remove('hidden');
                        settingsElement.classList.remove('hidden');
                        indicator.classList.remove('visible');
                    } else {
                        uiElement.classList.add('hidden');
                        materialMenu.classList.add('hidden');
                        currentDisplay.classList.add('hidden');
                        settingsElement.classList.add('hidden');
                        indicator.classList.add('visible');
                    }
                }
            }
        });

        // Voxel size slider
        const voxelSizeSlider = document.getElementById('voxelSizeSlider');
        const voxelSizeDisplay = document.getElementById('voxelSizeDisplay');
        
        voxelSizeSlider.addEventListener('input', (e) => {
            const newSize = parseInt(e.target.value);
            CONFIG.pixelSize = newSize;
            voxelSizeDisplay.textContent = newSize + 'mm';
            
            // Recalculate grid dimensions
            GRID_WIDTH = Math.floor(CONFIG.width / CONFIG.pixelSize);
            GRID_HEIGHT = Math.floor(CONFIG.height / CONFIG.pixelSize);
            
            // FULL RESET: Clear everything and rebuild from scratch
            game._simOrder = null;
            game.undoHistory = [];
            game.grid = new Array(GRID_WIDTH * GRID_HEIGHT).fill(MATERIAL.EMPTY);
            game.velocityX = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.velocityY = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.particleAge = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.humanBuiltBlocks = new Array(GRID_WIDTH * GRID_HEIGHT).fill(false);
            game.plantType = new Array(GRID_WIDTH * GRID_HEIGHT).fill(0);
            game.particleCount = 0;
            game.initialParticles = 0;
            game.humans = [];
            game.nextHumanId = 0;
            game.flies = [];
            game.nextFlyId = 0;
            game.leadBalls = [];
            game.nextLeadBallId = 0;
            game.worms = [];
            game.nextWormId = 0;
            if (game.gameMode === 'survival') { game.inventory = {}; game.generateTerrain(); }
            else game.generateBuildings();
        });

        // Place amount slider (how many voxels when placing materials)
        const placeAmountSlider = document.getElementById('placeAmountSlider');
        const placeAmountDisplay = document.getElementById('placeAmountDisplay');
        
        placeAmountSlider.addEventListener('input', (e) => {
            const newRadius = parseInt(e.target.value);
            CONFIG.spawnRadius = newRadius;
            placeAmountDisplay.textContent = newRadius;
        });

        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scale = Math.min(rect.width / CONFIG.width, rect.height / CONFIG.height);
            const offsetX = (rect.width - CONFIG.width * scale) / 2;
            const offsetY = (rect.height - CONFIG.height * scale) / 2;
            const dx = e.clientX - rect.left - offsetX;
            const dy = e.clientY - rect.top - offsetY;
            game.mouse.x = (dx / scale);
            game.mouse.y = (dy / scale);
            game.mouse.isInCanvas = dx >= 0 && dx <= CONFIG.width * scale && dy >= 0 && dy <= CONFIG.height * scale;
        });

        canvas.addEventListener('mouseenter', (e) => {
            e.preventDefault();
            game.mouse.isInCanvas = true;
        });

        canvas.addEventListener('mouseleave', (e) => {
            e.preventDefault();
            game.mouse.isInCanvas = false;
            game.mouse.down = false;
            game.mouse.rightDown = false;
        });

        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (e.button === 0) {
                game.mouse.down = true;
                const placeMat = game.gameMode === 'survival' ? survivalSelectedMaterial : (selectedMaterial && selectedMaterial.type === 'material' ? selectedMaterial.id : null);
                if (!destroyModeActive && !survivalDigMode && placeMat && e.shiftKey && game.mouse.isInCanvas) {
                    const mx = Math.floor(game.mouse.x / CONFIG.pixelSize);
                    const my = Math.floor(game.mouse.y / CONFIG.pixelSize);
                    lastLinePos = { x: mx, y: my };
                    game.placeSingle(mx, my, placeMat);
                    if (placeMat === MATERIAL.TRAPDOOR) game.closeAllTrapdoors();
                } else {
                    lastLinePos = null;
                }
                if (!destroyModeActive && game.gameMode !== 'survival' && selectedMaterial && selectedMaterial.type === 'special' && game.mouse.isInCanvas) {
                    const a = selectedMaterial.action;
                    if (a === 'human') game.spawnHuman();
                    else if (a === 'builder') game.spawnBuilderHuman();
                    else if (a === 'plant') game.spawnPlant();
                    else if (a === 'flies') game.spawnFly();
                    else if (a === 'worm') game.spawnWorm();
                    else if (a === 'bacteria') game.spawnMaterial(MATERIAL.BACTERIA);
                    else if (a === 'leadBall') game.spawnLeadBall();
                    else if (a === 'pellets') game.spawnPellets();
                    else if (a === 'spawner') game.spawnSpawner();
                    else if (a === 'bridge') game.spawnBridge();
                    else if (a === 'tower') game.spawnTower();
                    else if (a === 'arch') game.spawnArch();
                    else if (a === 'stairs') game.spawnStairs();
                    else if (a === 'wall') game.spawnWall();
                    else if (a === 'platform') game.spawnPlatform();
                    else if (a === 'pyramid') game.spawnPyramid();
                    else if (a === 'pillar') game.spawnPillar();
                }
            }
            if (e.button === 2) game.mouse.rightDown = true;
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (e.button === 0) {
                game.mouse.down = false;
                lastLinePos = null;
            }
            if (e.button === 2) game.mouse.rightDown = false;
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                game.mouse.down = false;
                lastLinePos = null;
            }
            if (e.button === 2) game.mouse.rightDown = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        window.addEventListener('keydown', (e) => { if (e.key === 'Shift') shiftKeyHeld = true; });
        window.addEventListener('keyup', (e) => { if (e.key === 'Shift') shiftKeyHeld = false; });

        // Continuous place/destroy while mouse held
        setInterval(() => {
            const isSurvDig = game.gameMode === 'survival' && survivalDigMode && game.mouse.down;
            if ((game.mouse.rightDown || (destroyModeActive && game.mouse.down) || isSurvDig) && game.mouse.isInCanvas) {
                game.destroyAtMouse();
            }
            const placeMat = game.gameMode === 'survival' ? survivalSelectedMaterial : (selectedMaterial && selectedMaterial.type === 'material' ? selectedMaterial.id : null);
            if (game.mouse.down && game.mouse.isInCanvas && !destroyModeActive && !isSurvDig && placeMat) {
                const mx = Math.floor(game.mouse.x / CONFIG.pixelSize);
                const my = Math.floor(game.mouse.y / CONFIG.pixelSize);
                if (shiftKeyHeld && lastLinePos && (lastLinePos.x !== mx || lastLinePos.y !== my)) {
                    game.placeLine(lastLinePos.x, lastLinePos.y, mx, my, placeMat);
                    lastLinePos = { x: mx, y: my };
                    if (placeMat === MATERIAL.TRAPDOOR) game.closeAllTrapdoors();
                } else if (!shiftKeyHeld) {
                    game.spawnMaterial(placeMat);
                }
            }
        }, 30);

        // Game loop
        function gameLoop() {
            game.update();
            game.render();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
